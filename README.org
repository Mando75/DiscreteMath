#+TITLE: Workbook for DM1
#+AUTHOR: Bryan Muller
#+EMAIL: mul13001@byui.edu
#+DATE: November 30
#+STARTUP donotshoweverything entitiespretty

* Track Pick
I will strive for track A. I believe that with diligent work and 
effort, I can master the topics. I will most likely attempt most 
of the coding challenges first in JavaScript, and then, time permitting, 
transfer them to LISP. I want to make it through all the exercises first,
and as the semester goes on, I'm hoping that the LISP will become easier, and 
I will begin to be able to solve all the problems just in LISP.  

#+BEGIN_SRC emacs-lisp
(setq inumber 457572324)
(list inumber)
#+END_SRC

#+RESULTS:
| 457572324 |

* Week 0

** CRC
   
*** What is a tetragramamalgam?
    Well if you break down the word into two parts, you get tetragram and amalgam.
    A tetragram is a 4 letter word, which makes sense if we are discussing EGGS (4 letters).
    An amalgam is a combination of things. So I would say that a tetragramamalgam is a set of 
    all possible combinations of the letters in the word EGGS.

*** EGGS
    let E = 1, G = 2 G = 3 S = 4   

    (1234 1243 1432 2134 2314 2341 2413 2431 4123 4213 4231)
    (EGGS EGSG ESGG GEGS GGES GGSE GSEG GSGE SEGG SGEG SGGE)

    
*** Sand dune picture 
    I think this represents discrete math in a couple ways. First of all, the desert is made up 
    up of discrete particles of sand. Also, discrete math is a vast field. Each grain of sand could
    represent a facet of the field. 
   
    
** DGZ 

   THE TIME HAS COME THE WALRUS SAID TO
   TALK OF MANY THINGS OF SHOES AND SHIPS
   AND SEALING WAX OF CABBAGES AND KINGS
   AND WHY THE SEA IS BOILING HOT AND WHETHER PIGS HAVE WINGS
 
** CHJ

   This was the smallest ratio I could find assuming y is a vowel:
   
   strengths v/c 1/8

   
** DOK

   
   1 * 2 * 3 = 6 

   2 * 3 * 5 = 30

   3 * 4 * 7 = 84

   4 * 5 * 9 = 260

   5 * 6 * 11 = 330

   6 * 7 * 13 = 546

   7 * 8 * 15 = 840

   8 * 9 * 17 = 1224

   9 * 10 * 19 = 1710

   10 * 11 * 21 = 2310


   Patterns: 
   
*** The results are all even numbers

*** The results are all divisible by 3

*** The results are all divisible by 6

*** The (2x) + 1 terms are the ascending odd numbers

*** The last digits of the product seem to be following a pattern of 6040060400... 

** UJF 
   When approaching this problem, I had the same idea as what was later suggested in the hint.
   Because we know the circle is inscribed within an equilateral triangle, we can use basic trigonmetry 
   to find the length of one of its sides. We can continue this pattern by using trigonmetry to then find the radius of 
   the circle surrounding the triangle, and so forth. This approach was also later hinted at by Brother Neff. This runs into 
   an issue of course, because as we approach the outer edge, we are unable to know how many or what shapes there are. 
   That being said, there is a pattern to the trig. After each iteration, the ratio that is used to represent the angle is 
   modified by a factor of one in the denominator. What begins with pi/3 moves to pi/4 -> pi/5 -> pi/6 -> pi/7 -> pi/8 etc.
   Say there are n shapes within this structure. We could construct a function/limit where X initial =3 (and x is the denominator of the radian) 
   as x approaches n, that would allow us to solve this problem. Sadly my calculus skills were too rusty to actually construct the limit, but I believe that 
   it is possible. For this reason, I would say that this is a continuous math problem. Perhaps there is a better 'discrete' method of approaching this problem,
   but this is the method I thought of. 
   

UPDATE: Here is a Javascript solution. The limit of the radius as it approaches the num of shapes is 8.7 
#+BEGIN_SRC javascript
const getSide = (x, it) => {
  return x / Math.cos(Math.PI/it);
}

const getLimit = (sides) => {
  let rad = 1.0;
  for(let i = 3; i < sides; i++) {
    rad = getSide(rad, i);
  }
  console.log(rad)
}

getLimit(10000000)
#+END_SRC

* Week 1 ABC

** USV
 #+BEGIN_SRC emacs-lisp
(rot13 "Or pyrire jvgu ahzoref. Svaq n jnl gb vafreg vagb gurfr gra yvarf gur sbhe fgnaqneq zngu bcrengbef 
(+, -, \gvzrf, \qvi), be ! (snpgbevny), be \enqvp (fdhner ebbg), naq cneragurfrf sbe tebhcvat, gb znxr gra
 qvssrerag rkcerffvbaf gung rnpu rinyhngr gb 6. Sbe rknzcyr: \enqvp4 + \enqvp4 + \enqvp4 = 6.")
 
 #+END_SRC

 #+RESULTS:
 : Be clever with numbers. Find a way to insert into these ten lines the four standard math operators 
 : (+, -, times, div), or ! (factorial), or adic (square root), and parentheses for grouping, to make ten
 :  different expressions that each evaluate to 6. For example: adic4 + adic4 + adic4 = 6.

    ( 0! + 0! + 0! )!                     = 6 
    ( 1 + 1 + 1 )!                        = 6 
    ( 2 + 2 + 2 )                         = 6 
    ( 3 * 3 - 3 )                         = 6 
    ( ^[adic(4*4)]! / 4 )                 = 6 
    ( 5 / 5 + 5 )                         = 6 
    ( 6 / 6 * 6 )                         = 6 
    ( 7 - 7 / 7 )                         = 6 
    ( ^[adic(8+8)]! / 8)!                 = 6 
    (^[adic(9)]* ^[adic(9)] - ^[adic(9)]) = 6 

** OQP
   I worked through the entire primer notebook.
   #+BEGIN_SRC emacs-lisp
   (+ 1 2 3 4)
   #+END_SRC

   #+RESULTS:
   : 10

** ABF - Which proposition is false?
   I would say the proposition on numbers. To quote, "The square of a number is more than double that number."
   Assuming that this is a statement for every case, it is clearly false. 2 * 2 = 4, 2^2 = 4 therefore 2*2 = 2^2, so
   that satement is false for that case, rendering it untrue if applied to all numbers. 

** UCA
   It is my understanding of the text that propositions can be true OR false.
*** Propositions
    Rain falls down. 
    Chickens are birds
    Fish have fur
*** Non-Propositions
    Fetch me some water
    What is your middle name?
    How many colors are there?
** ODS
*** Guide:
    P = proposition
    NP = non-proposition
***   
      1. P true
      2. P false
      3. P false
      4. NP n/a
      5. P Depending on the values of each variable, it could be true or false
      6. NP n/a
      7. P given that x = 3, than it is true, otherwise it is false
      8. NP n/a
** UGX
   'v' \in C 

** OGR   
   1. simple proposition
   2. compound proposition
   3. compound proposition
   4. compound proposition

   So only the first item is a simple proposition.
   
** ABG
   #+BEGIN_SRC emacs-lisp
 (defun xor (p q)
   (if p (not q) q))
 (setq true t false nil)
 (list (xor false false)
       (xor false true)
       (xor true false)
       (xor true true))
   #+END_SRC

   #+RESULTS:
   | nil | t | t | nil |

** UWM
   1. Two plus two does not equal four
   2. Two plus 1 is greater than four
   3. Toronto is not the capital of Germany
   4. A total eclipse happens frequently
   5. Special measures must not be taken to deal with the current situation
   

** OPZ 
   1. I did not study
   2. I studied or I got an F on the test
   3. I studied and I got an F on the test
   4. I did not study and I did not get an F on the test
   5. I did not study or I got an F on the test
   6. I did not study and I did not get an F on the test
   
** UOX  
   Check special forms
   1. =when=
   2. =unless=
   3. =cond=
   4. =not=
   5. =and=
   6. =or=

      According the the gnu emacs manual, "A special form is a primitive function specially
      marked so that its arguments are not all evaluated. For example, the if function executes 
      only a certain part of its code block depending on which of the conditions is evaluated. 
   
** OTX
   1. xor
   2. or
   3. or
   4. or
   5. xor
   6. xor
   
** UOT 
  
Truth table for equation 2:

| p | q | r | p and q (A) | not r (B) | (A) or (B) |
|---+---+---+-------------+-----------+------------|
| 0 | 0 | 0 |           0 |         1 |          1 |
| 0 | 0 | 1 |           0 |         0 |          0 |
| 0 | 1 | 0 |           0 |         1 |          1 |
| 0 | 1 | 1 |           0 |         0 |          0 |
| 1 | 0 | 0 |           0 |         1 |          1 |
| 1 | 0 | 1 |           0 |         0 |          0 |
| 1 | 1 | 0 |           1 |         1 |          1 |
| 1 | 1 | 1 |           1 |         0 |          1 |

Comparison between the 2:
| EQ1 | EQ2 |
|-----+-----|
|   0 |   1 |
|   0 |   0 |
|   0 |   1 |
|   0 |   0 |
|   1 |   1 |
|   0 |   0 |
|   1 |   1 |
|   1 |   1 |

** ABK
#+BEGIN_SRC emacs-lisp
(setq A [1 2 3 4 5 6 7 8]
      B [5 6 7 8 9 10 11 12]
      A-intersect-B[5 6 7 8])
#+END_SRC

#+RESULTS:
: [5 6 7 8]

#+BEGIN_SRC emacs-lisp
(setq A [1 2 3 4 5 6 7 8]
      B [5 6 7 8 9 10 11 12]
      A-union-B [1  2 3 4 5 6 7 8 9 10 11 12])
#+END_SRC

#+RESULTS:
: [1 2 3 4 5 6 7 8 9 10 11 12]


** OIM  
   The first column represents the decimal value given in binary by the last three columns. 
   If A,B,C could be represented as being true (1), and their compliments as being false (0), the middle column
   reflects the binary number in its set logic. 
   
** UIN
   #+BEGIN_SRC emacs-lisp
(require 'cl)
(set-difference '(q w e r t y u i o p a s d f g h j k l z x c v b n m) '(a e i o u h k l m n p w))
   
   #+END_SRC

   #+RESULTS:
   | q | r | t | y | s | d | f | g | j | z | x | c | v | b |


** Email Puzzle 2 - the 5 hat problem
   
   The answer is 3: She has a white hat anc can prove it. 

   Let's call student one i, two, j, three k respectively. 

   We know immediately that j and k cannot both be wearing a red hat, because i would open his eyes,
   see two red hats, and know that he could not be wearing a red hat because there were only two in the box. 
   In otherwords, we know that (j AND k) = FALSE

   We also know that i and k are both not wearing a red hat for the same reason, so (i AND k) = FALSE
   When j hears that i does not know the color, he can deduce the following. Either he (j) and k are both wearing white hats, 
   or one of them is wearing a red hat. In otherwords ((NOT j AND NOT k) OR (j OR k)). 
   If j opens his eyes and sees that k has a red hat, then  he knows that he must be wearing a white, 
   because they both cannot be wearing red. This appears not to be the case as he says he is uncertain, which means he saw a white
   hat on k. This means that he (j) could be wearing either a red or a white hat (see above). Because
   he is unsure, k can deduce that she must be wearing a white hat. 


** OJL
   
   | A   | 4 âˆª 5 âˆª 7 âˆª 6	 | (pâˆ§Â¬qâˆ§Â¬r)âˆ¨(pâˆ§Â¬qâˆ§r)âˆ¨(pâˆ§qâˆ§r)âˆ¨(pâˆ§qâˆ§Â¬r) | correct |
   | B	 | 2 âˆª 3 âˆª 7 âˆª 6	 | (Â¬pâˆ§qâˆ§Â¬r)âˆ¨(Â¬pâˆ§qâˆ§r)âˆ¨(pâˆ§qâˆ§r)âˆ¨(pâˆ§qâˆ§Â¬r) | correct |
   | C	 | 1 âˆª 3 âˆª 5 âˆª 7	 | (Â¬pâˆ§Â¬qâˆ§r)âˆ¨(Â¬pâˆ§qâˆ§r)âˆ¨(pâˆ§Â¬qâˆ§r)âˆ¨(pâˆ§qâˆ§r) | correct |
** UCG

*** 1. A or B = C
    C = [verve vim vigor butter vinegar pepper]

*** 2. A and B = D
    D = [vigor]

*** 3. subset of C that start with 'v'
    [verve vim vigor vinegar]

*** 4. subset of C that end with 'r'
    [vigor butter vinegar pepper]
*** 5. subset of C that start with 'v' and end with 'r'
    [vigor vinegar]
*** 6. subset of D that have six letters
    [ ] -> empty
** OIO
   #+BEGIN_SRC emacs-lisp
(setq A [ s i z e]
      a (length A)
      B [b i g g e r i n s i z e]
      b (length B)
      A-is-a-subset-of-B (subsetp (append A nil) (append B nil))
      a-is-less-than-or-equal-to-b (<= a b))
   #+END_SRC

   #+RESULTS:
   : t

#+BEGIN_SRC emacs-lisp :results silent
  
#+END_SRC 
** UIJ
   The logical operator -> represents 'if... then', in other words, if the left side is true,
   then the right side is also true. If A is a subset of B, that means that anything in A(3) 
   is inside of B(2) (which is also in set U(1)). This means, that if a point is inside A,
   than it is also inside B (and U). This can be expressed with the \rightarrow symbol: A \rightarrow B (\rightarrow U). 
** OQT
*** 1. If I study I get an A on the test
*** 2. I did not study or I did not get an A on the test
*** 3. If I do not study, then I study or get an A on the test
*** 4. If I do not study, then I do not get an A on the test
** UTQ
   1. p ^ q
   2. \not p ^ q
   3. p ^ \not q
   4. (\not p ^ \not q) v (p ^ q)
** OYU
   1. p implies q
   2. p so q
   3. p therefore q
   4. every time p, q
** UOH
q->p
q->p
p<->q
** OZD
   1. if true than false : false
   2. if true than false : false
   3. if false than true : true
   4. if true than true : true
** UZM
   1. true
   2. false
   3. false
   4. true
** OOY
   1. If you want to win, then you must sign up
   2. If I go outside, then I get cold
   3. If you are an A student, then you will get a scholarship
   4. If you leave now, then you will get there on time
   5. If I act now, then I get half off

** UFZ
   Given p->q
   Converse q->p
   Inverse \not p -> \not q
   Contrapositive \not q -> \not p

** OKJ
*** 1. If it rains today, we won't go to the park   
    it rains = p we won't go to the park = 1

    converse: If we don't go to the park, it will rain
    inverse: If it does not rain today, we will go to the park
    contrapositive: We will go to the park if it does not rain.
*** 2. If you do your homework, Iâ€™ll give you a pat on the back.

    you do your homework = p I give you a pat on the back = q

    converse: If I give you a pat on the back, then you will do your homework.
    inverse: If you do not do your homework, I will not give you a pat on the back.
    contrapostive: If I do not give you a pat on the back, you will not do your homework
*** 3. Whenever I babysit, I get sick
    I babysit = p I get sick = q

    converse: If I get sick, then I babysit
    inverse: If I do not babysit, then I do not get sick
    contrapositive: if I do not get sick, then I do not babysit
*** 4. Every time there is a quiz, I go to class
    There is a quiz = p I go to class = q

    converse: Every time I go to class, there is a quiz
    inverse: If there is not a quiz, then I do not go to class
    contrapositive: If I do not go to class, then there is no quiz
*** 5. I wake up late when I stay up past my bedtime
    I wake up late = p I stay up past my bedtime = q

    converse: When I stay up past my bedtime, I wake up late.
    inverse: When I don't wake up late, I don't stay up past my bedtime
    contrapositive: When I don't stay up past my bedtime, I don't wake up late
** UVH
*** 1. p -> q
    
    | p | q | p->q |
    | 0 | 0 |    1 |
    | 0 | 1 |    1 |
    | 1 | 0 |    0 |
    | 1 | 1 |    1 |


*** 2. p \oplus q
    | p | q | p \oplus q |
    | 0 | 0 |     0 |
    | 0 | 1 |     1 |
    | 1 | 0 |     1 |
    | 1 | 1 |     0 |

*** 3. p â†’ q  
    | p | q | p->q |
    | 0 | 0 |    1 |
    | 0 | 1 |    1 |
    | 1 | 0 |    0 |
    | 1 | 1 |    1 |

    
*** 4. Â¬pâ†’q
    | p | \not p | q | Â¬pâ†’q |
    | 0 |   1 | 0 |    0 |
    | 0 |   1 | 1 |    1 |
    | 1 |   0 | 0 |    1 |
    | 1 |   0 | 1 |    1 |

*** 5. pâˆ§Â¬q   
    | p | q | \not q | ^ |
    | 0 | 0 |   1 | 1 |
    | 0 | 1 |   0 | 0 |
    | 1 | 0 |   1 | 1 |
    | 1 | 1 |   0 | 1 |

** OJM 

*** 1. pâ†’(Â¬p)
    | p | \not p | pâ†’(Â¬p) |
    | 0 |   1 |      1 |
    | 1 |   0 |      0 |

*** 2. pâ†”q

    | p | q | pâ†”q |
    | 0 | 0 |   1 |
    | 0 | 1 |   0 |
    | 1 | 0 |   0 |
    | 1 | 1 |   1 |

*** 3. pâ†”(Â¬p)
    | p | \not p | pâ†”(Â¬p) |
    | 0 |   1 |      0 |
    | 1 |   0 |      0 |

*** 4. pâˆ§p

    | p | pâˆ§p |
    | 0 |   0 |
    | 1 |   1 |

*** 5. pâˆ¨p

    | p | pâˆ¨p |
    | 0 |   0 |
    | 1 |   1 |

    
** ULQ

   | p | q | r | s | p->q | q->r | (p->q)->(q->r) | (r->s) | (p->q)->(q->r)->(r->s) |
   | 0 | 0 | 0 | 0 |    1 |    1 |              1 |      1 |                      1 |
   | 0 | 0 | 0 | 1 |    1 |    1 |              1 |      1 |                      1 |
   | 0 | 0 | 1 | 0 |    1 |    1 |              1 |      0 |                      0 |
   | 0 | 0 | 1 | 1 |    1 |    1 |              1 |      1 |                      1 |
   | 0 | 1 | 0 | 0 |    1 |    0 |              0 |      1 |                      1 |
   | 0 | 1 | 0 | 1 |    1 |    0 |              0 |      1 |                      1 |
   | 0 | 1 | 1 | 0 |    1 |    1 |              1 |      0 |                      0 |
   | 0 | 1 | 1 | 1 |    1 |    1 |              1 |      1 |                      1 |
   | 1 | 0 | 0 | 0 |    0 |    1 |              1 |      1 |                      1 |
   | 1 | 0 | 0 | 1 |    0 |    1 |              1 |      1 |                      1 |
   | 1 | 0 | 1 | 0 |    0 |    1 |              1 |      0 |                      0 |
   | 1 | 0 | 1 | 1 |    0 |    1 |              1 |      1 |                      1 |
   | 1 | 1 | 0 | 0 |    1 |    0 |              0 |      1 |                      1 |
   | 1 | 1 | 0 | 1 |    1 |    0 |              0 |      1 |                      1 |
   | 1 | 1 | 1 | 0 |    1 |    1 |              1 |      0 |                      0 |
   | 1 | 1 | 1 | 1 |    1 |    1 |              1 |      1 |                      1 |

** OTD
(p âˆ¨ q) âˆ§ (Â¬ p âˆ¨ r) â†’ (q V r)
   | p | q | r | \not p | p V q | \not p V r | (p V q) V (\not p V r) | (q V r) | ((p âˆ¨ q) âˆ§ (Â¬ p âˆ¨ r)) â†’ (q V r) |
   | 0 | 0 | 0 |   1 |     0 |       1 |                   1 |       0 |                               0 |
   | 0 | 0 | 1 |   1 |     0 |       1 |                   1 |       1 |                               1 |
   | 0 | 1 | 0 |   1 |     1 |       1 |                   1 |       1 |                               1 |
   | 0 | 1 | 1 |   1 |     1 |       1 |                   1 |       1 |                               1 |
   | 1 | 0 | 0 |   0 |     1 |       0 |                   1 |       0 |                               0 |
   | 1 | 0 | 1 |   0 |     1 |       1 |                   1 |       1 |                               1 |
   | 1 | 1 | 0 |   0 |     1 |       0 |                   1 |       1 |                               1 |
   | 1 | 1 | 1 |   0 |     1 |       1 |                   1 |       1 |                               1 |
** UJU
*** 1.    
    | p | q | p V q | <-> | q | p | q V p |
    | 0 | 0 |     0 |   1 | 0 | 0 |     0 |
    | 0 | 1 |     1 |   1 | 0 | 1 |     1 |
    | 1 | 0 |     1 |   1 | 1 | 0 |     1 |
    | 1 | 1 |     1 |   1 | 1 | 1 |     1 |
*** 2. 

    | p | q | p ^ q | <-> | p | q | q ^ p |
    | 0 | 0 |     0 |   1 | 0 | 0 |     0 |
    | 0 | 1 |     0 |   1 | 0 | 1 |     0 |
    | 1 | 0 |     0 |   1 | 1 | 0 |     0 |
    | 1 | 1 |     1 |   1 | 1 | 1 |     1 |
** OLH
*** 1. (pâˆ¨q)âˆ¨râ‰¡pâˆ¨(qâˆ¨r)

| p | q | p V q | r | t V r | <-> | p V e | q V r |
| 0 | 0 |     0 | 0 |     0 |   1 |     0 |     0 |
| 0 | 0 |     0 | 1 |     1 |   1 |     1 |     1 |
| 0 | 1 |     1 | 0 |     1 |   1 |     1 |     1 |
| 0 | 1 |     1 | 1 |     1 |   1 |     1 |     1 |
| 1 | 0 |     1 | 0 |     1 |   1 |     1 |     0 |
| 1 | 0 |     1 | 1 |     1 |   1 |     1 |     1 |
| 1 | 1 |     1 | 0 |     1 |   1 |     1 |     1 |
| 1 | 1 |     1 | 1 |     1 |   1 |     1 |     1 |
*** 2. (pâˆ§q)âˆ§râ‰¡pâˆ§(qâˆ§r)

    | p | q | p ^ q | r | t ^ r | <-> | p ^ e | q ^ r |
    | 0 | 0 |     0 | 0 |     0 |   1 |     0 |     0 |
    | 0 | 0 |     0 | 1 |     0 |   1 |     0 |     0 |
    | 0 | 1 |     0 | 0 |     0 |   1 |     0 |     0 |
    | 0 | 1 |     0 | 1 |     0 |   1 |     0 |     1 |
    | 1 | 0 |     0 | 0 |     0 |   1 |     0 |     0 |
    | 1 | 0 |     0 | 1 |     0 |   1 |     0 |     0 |
    | 1 | 1 |     1 | 0 |     0 |   1 |     0 |     0 |
    | 1 | 1 |     1 | 1 |     1 |   1 |     1 |     1 |
** UWY
*** 1. pâˆ§(qâˆ¨r)â‰¡(pâˆ§q)âˆ¨(pâˆ§r)

    | p | q | r | (q V r) | ^ p | <-> | (p ^ q) | V | (p ^ r) |
    | 0 | 0 | 0 |       0 |   0 |   1 |       0 | 0 |       0 |
    | 0 | 0 | 1 |       1 |   0 |   1 |       0 | 0 |       0 |
    | 0 | 1 | 0 |       1 |   0 |   1 |       0 | 0 |       0 |
    | 0 | 1 | 1 |       1 |   0 |   1 |       0 | 0 |       0 |
    | 1 | 0 | 0 |       0 |   0 |   1 |       0 | 0 |       0 |
    | 1 | 0 | 1 |       1 |   1 |   1 |       0 | 1 |       1 |
    | 1 | 1 | 0 |       1 |   1 |   1 |       1 | 1 |       0 |
    | 1 | 1 | 1 |       1 |   1 |   1 |       1 | 1 |       1 |
*** 2. pâˆ¨(qâˆ§r)â‰¡(pâˆ¨q)âˆ§(pâˆ¨r)

    | p | q | r | (q ^ r) | V p | <-> | p V q | ^ | p V r |
    | 0 | 0 | 0 |       0 |   0 |   1 |     0 | 0 |     0 |
    | 0 | 0 | 1 |       0 |   0 |   1 |     0 | 0 |     1 |
    | 0 | 1 | 0 |       0 |   0 |   1 |     1 | 0 |     0 |
    | 0 | 1 | 1 |       1 |   1 |   1 |     1 | 1 |     1 |
    | 1 | 0 | 0 |       0 |   1 |   1 |     1 | 1 |     1 |
    | 1 | 0 | 1 |       0 |   1 |   1 |     1 | 1 |     1 |
    | 1 | 1 | 0 |       0 |   1 |   1 |     1 | 1 |     1 |
    | 1 | 1 | 1 |       1 |   1 |   1 |     1 | 1 |     1 |
** OBW
*** 1. Â¬(pâˆ¨q)â‰¡Â¬pâˆ§Â¬q 
    
    | p | q | (p V q) | \not | <-> | \not p | ^ | \not q |
    | 0 | 0 |       0 | 1 |   1 |   1 | 1 |   1 |
    | 0 | 1 |       1 | 0 |   1 |   1 | 0 |   0 |
    | 1 | 0 |       1 | 0 |   1 |   0 | 0 |   1 |
    | 1 | 1 |       1 | 0 |   1 |   0 | 0 |   0 |

*** 2. Â¬(pâˆ§q)â‰¡Â¬pâˆ¨Â¬q

    | p | q | (p ^ q) | \not | <-> | \not p | V | \not q |
    | 0 | 0 |       0 | 1 |   1 |   1 | 1 |   1 |
    | 0 | 1 |       0 | 1 |   1 |   1 | 1 |   0 |
    | 1 | 0 |       0 | 1 |   1 |   0 | 1 |   1 |
    | 1 | 1 |       1 | 0 |   1 |   0 | 0 |   0 |
** USL
*** 1. pâˆ§1â‰¡p
    
    | p | ^ 1 | <-> | p |
    | 0 |   0 |   0 | 0 |
    | 1 |   1 |   1 | 1 |
*** 2. pâˆ¨0â‰¡p   

    | p | V 0 | <-> | p |
    | 0 |   0 |   1 | 0 |
    | 1 |   1 |   1 | 1 |
*** 3. Â¬Â¬pâ‰¡p

    | p | \not \not | <-> | p |
    | 0 |   0 |   1 | 0 |
    | 1 |   1 |   1 | 1 |

*** 4. pâˆ§0â‰¡0   

    | p | ^ 0 | <-> | 0 |
    | 0 |   0 |   1 | 0 |
    | 1 |   0 |   1 | 0 |

*** 5. pâˆ¨1â‰¡1

    | p | V 1 | <-> | 1 |
    | 0 |   1 |   1 | 1 |
    | 1 |   1 |   1 | 1 |

** OYP
   1. matches with USL.1 (idempotence)
   2. matches with USL.5 (absorption)
   3. matches with USL.2 (idempotence)
   4. matches with USL.4 (absorption)
   5. matches with USL.3 (double negation)
   
** UBV

*** 1. Winning the first round is necessary for winning the trophy

    p = winning the first round q = winning the trophy

   \not (p ^ q) = (\not p) ^ (\not q)
   
   If you lose the first round then you lose the trophy

*** 2. Winning the tournament is sufficient for winning the trophy

    p = winning the tournament q = winning the trophy

    Losing the the tournament is not sufficient for winning the trophy

*** 3. I am powerful and successful

    p = I am powerful q = successful
    \not (p ^ q) = (\not p) ^ (\not q)

    I am not powerful, or I am not successful

*** 4. You can pass or fail this test

    p = You can pass q = fail this test
    
    You can fail and you can pass this test

*** 5. Getting an A on the final exam is necessary and sufficient for passing this class

    p = Getting an A on the final exam q = passing this class

    If I get an A on the final exam, then I fail this class.
    If I do not get an A on the final exam, then I pass this class. 

** OKQ 

| p | q | r | p \leftrightarrow q | \wedge | q \leftrightarrow r | \leftrightarrow | p \leftrightarrow | q \wedge r |
| 0 | 0 | 0 |     1 | 1 |     1 | 1 |   1 |     0 |
| 0 | 0 | 1 |     1 | 0 |     0 | 0 |   1 |     0 |
| 0 | 1 | 0 |     0 | 0 |     0 | 0 |   1 |     0 |
| 0 | 1 | 1 |     0 | 0 |     1 | 1 |   0 |     1 |
| 1 | 0 | 0 |     0 | 0 |     1 | 1 |   0 |     0 |
| 1 | 0 | 1 |     0 | 0 |     0 | 1 |   0 |     0 |
| 1 | 1 | 0 |     1 | 0 |     0 | 1 |   0 |     0 |
| 1 | 1 | 1 |     1 | 1 |     1 | 1 |   1 |     1 |

** UKF

   | p | q | \not p | \leftrightarrow q | \leftrightarrow | p \leftrightarrow | \not q |
   | 0 | 0 |   1 |   0 | 1 |   0 |   1 |
   | 0 | 1 |   1 |   1 | 1 |   1 |   0 |
   | 1 | 0 |   0 |   1 | 1 |   1 |   1 |
   | 1 | 1 |   0 |   0 | 1 |   0 |   0 |

** OKL
   
| p | q | r | p V q | \wedge | \not p V r | -> | q V r |
| 0 | 0 | 0 |     0 | 0 |       1 |  1 |     0 |
| 0 | 0 | 1 |     0 | 0 |       1 |  1 |     1 |
| 0 | 1 | 0 |     1 | 1 |       1 |  1 |     1 |
| 0 | 1 | 1 |     1 | 1 |       1 |  1 |     1 |
| 1 | 0 | 0 |     1 | 0 |       0 |  1 |     0 |
| 1 | 0 | 1 |     1 | 1 |       1 |  1 |     1 |
| 1 | 1 | 0 |     1 | 0 |       0 |  1 |     1 |
| 1 | 1 | 1 |     1 | 1 |       1 |  1 |     1 |

It is a tautology

** UEZ
 (p âˆ§ q) âˆ§ Â¬ r

| p | q | r | p \wedge q | \wedge | \not r |
| 0 | 0 | 0 |     0 | 0 |   1 |
| 0 | 0 | 1 |     0 | 0 |   0 |
| 0 | 1 | 0 |     0 | 0 |   1 |
| 0 | 1 | 1 |     0 | 0 |   0 |
| 1 | 0 | 0 |     0 | 0 |   1 |
| 1 | 0 | 1 |     0 | 0 |   0 |
| 1 | 1 | 0 |     1 | 1 |   1 |
| 1 | 1 | 1 |     1 | 0 |   0 |

** OYW

#+BEGIN_SRC emacs-lisp
(defun <-- (p q)
   "Conditional: p if q"
   (and p (not q))
)

(defun xor (p q)
  "Exclusive or."
  (if p (not q) q))  

  (defun --> (p q)
    "Conditional: p only if q"
    (or (not p) q))

  (defun <--> (p q)
    "Biconditional: p if and only if q"
    (and (--> p q) (--> q p)))

  (defun valid-connective (op)
    (or (eq op 'and) (eq op 'or) (eq op 'xor)
        (eq op '-->) (eq op '<-->)))
  (defun prop-eval (prop)
    (unless (and (vectorp prop)
                 (= 3 (length prop))
                 (valid-connective (elt prop 1)))
      (error "bad parameters"))
    (let* ((op (elt prop 1))
           (l (eval (elt prop 0)))
           (r (eval (elt prop 2)))
           (lval (y-or-n-p (mapconcat 'symbol-name l " ")))
           (rval (y-or-n-p (mapconcat 'symbol-name r " ")))
           (result (eval (list op lval rval))))
      (list l (list lval) op r (list rval) 'yields result)))

  ;(let* ((p [It is raining])
     ;    (q [The grass is wet])
    ;     (p-and-q [p and q]))
   ; (prop-eval p-and-q))


  ;(let* ((p [It is raining])
      ;   (q [The grass is wet])
     ;    (p-onlyif-q [p --> q]))
    ;(prop-eval p-onlyif-q ))

; BEGIN MY TRIES
; I commented them out as to only run one at a time...


  ;(let* ((p [My car runs])
   ;      (q [There is gas in the tank])
    ;     (p-onlyif-q [p <--> q]))
     ;(prop-eval p-onlyif-q))

     ;(let* ((p [I learn discrete math])
      ;      (q [I study hard])
       ;     (p-and-q [p xor q]))
        ;    (prop-eval p-xor-q))

   (let* ((p [It's cold])
          (q [It snows])
          (p-if-q [p <-- q]))
          (prop-eval p-if-q)) 
#+END_SRC

#+RESULTS:
| [It rains] | (t) | or | [It snows] | (nil) | yields | t |

** UEF
#+BEGIN_SRC emacs-lisp

(defun --> (p q)
  "Conditional: p only if q"
  (or (not p) q))

(defun <--> (p q)
  "Biconditional: p if and only if q"
  (and (--> p q) (--> q p)))

(defun valid-connective (op)
  (or (eq op 'and) (eq op 'or) (eq op 'xor)
      (eq op '-->) (eq op '<-->)))
(defun stringify (prop)
  (let* ((str (mapconcat 'symbol-name prop " ")))
    (downcase (substring str 0 (- (length str) 1)))))

(defun fancier-prompt (str)
  (let* ((prompt (concat "Is it the case that " str "? "))
         (answer (y-or-n-p-with-timeout prompt 5 t)))
    (princ (format "Given %s is %s\n" str (if answer 'true: 'false:)))
    answer))

(defun fancier-output (result l op r)
  (princ (format "It is %s that %s %s %s.\n"
                 (if result 'true 'false)
                 l op r)))

(defun prop-eval (prop)
  (unless (and (vectorp prop)
               (= 3 (length prop))
               (valid-connective (elt prop 1)))
    (error "bad parameters"))
  (let* ((op (elt prop 1))
         (l (eval (elt prop 0)))
         (r (eval (elt prop 2)))
         (lstr (stringify l))
         (rstr (stringify r))
         (lval (fancier-prompt lstr))
         (rval (fancier-prompt rstr))
         (result (eval (list op lval rval))))
    (fancier-output result lstr op rstr)))

(let* ((p [It is raining.])
       (q [The grass is wet.])
       (p-onlyif-q [p --> q]))
  (prop-eval p-onlyif-q))
#+END_SRC

#+RESULTS:
: It is true that it is raining --> the grass is wet.

In the prop-eval function, within the unless-> and conditional, you could replace the '(= 3 (length prop))' with 't',
you can then pass in any length of parameter. It may not be a valid input, but that is where you'd need to start if you wanted
to implement more complex expressions. 

** OUB
  #+BEGIN_SRC emacs-lisp
(defun <-- (p q)
"Conditional: p if q"
(and (not q) p))

(defun --> (p q)
  "Conditional: p only if q"
  (or (not p) q))

(defun <--> (p q)
  "Biconditional: p if and only if q"
  ;(and (--> p q) (--> q p))
  (or (<-- p q) (<-- q))
  ;(or (and p q) (and (not p) (not q)))
)

(defun valid-connective (op)
  (or (eq op 'and) (eq op 'or) (eq op 'xor)
      (eq op '-->) (eq op '<-->)))
(defun stringify (prop)
  (let* ((str (mapconcat 'symbol-name prop " ")))
    (downcase (substring str 0 (- (length str) 1)))))

(defun fancier-prompt (str)
  (let* ((prompt (concat "Is it the case that " str "? "))
         (answer (y-or-n-p-with-timeout prompt 5 t)))
    (princ (format "Given %s is %s\n" str (if answer 'true: 'false:)))
    answer))

(defun fancier-output (result l op r)
  (princ (format "It is %s that %s %s %s.\n"
                 (if result 'true 'false)
                 l op r)))

(defun prop-eval (prop)
  (unless (and (vectorp prop)
               (= 3 (length prop))
               (valid-connective (elt prop 1)))
    (error "bad parameters"))
  (let* ((op (elt prop 1))
         (l (eval (elt prop 0)))
         (r (eval (elt prop 2)))
         (lstr (stringify l))
         (rstr (stringify r))
         (lval (fancier-prompt lstr))
         (rval (fancier-prompt rstr))
         (result (eval (list op lval rval))))
    (fancier-output result lstr op rstr)))

(let* ((p [It is raining.])
       (q [The grass is wet.])
       (p-onlyif-q [p <--> q]))
  (prop-eval p-onlyif-q))

  
  #+END_SRC 

  #+RESULTS:
  : It is true that it is raining <--> the grass is wet.

** TODO UQY

#+BEGIN_SRC emacs-lisp
(defun not1 (x)
  (* (- x 1) -1)
)

(defun and2 (x y)
  (* x y)
)

(defun or2 (x y)
  ()
)

(defun truth-table-row-inputs (i)
  (elt [[0 0 0] [0 0 1] [0 1 0] [0 1 1]
        [1 0 0] [1 0 1] [1 1 0] [1 1 1]] i))

(defun truth-table-row-with-output (i func)
  (let* ((inputs (append (truth-table-row-inputs i) nil))
         (output (apply func inputs)))
    (apply 'vector (append inputs (list output)))))

(defun f1 (p q r)
  (or2 (and2 p q) (not1 r)))

(defun f2 (p q r)
  (and2 p (or2 q (not1 r))))

(defun f3 (p q r)
  (or2 p (and2 q r)))

(defun generate-truth-table-for (func)
  (vector (truth-table-row-with-output 0 func)
          (truth-table-row-with-output 1 func)
          (truth-table-row-with-output 2 func)
          (truth-table-row-with-output 3 func)
          (truth-table-row-with-output 4 func)
          (truth-table-row-with-output 5 func)
          (truth-table-row-with-output 6 func)
          (truth-table-row-with-output 7 func)))

(equal (generate-truth-table-for 'f1)
       [[0 0 0 1]
        [0 0 1 0]
        [0 1 0 1]
        [0 1 1 0]
        [1 0 0 1]
        [1 0 1 0]
        [1 1 0 1]
        [1 1 1 1]])
(equal (generate-truth-table-for 'f2)
       [[0 0 0 0]
        [0 0 1 0]
        [0 1 0 0]
        [0 1 1 0]
        [1 0 0 1]
        [1 0 1 0]
        [1 1 0 1]
        [1 1 1 1]])
(equal (generate-truth-table-for 'f3)
       [[0 0 0 0]
        [0 0 1 0]
        [0 1 0 0]
        [0 1 1 1]
        [1 0 0 1]
        [1 0 1 1]
        [1 1 0 1]
        [1 1 1 1]])
#+END_SRC

#+RESULTS:

* Week 2 DEF
  :LOGBOOK:
  CLOCK: [2017-09-29 Fri 22:53]--[2017-09-29 Fri 23:03] =>  0:10
  CLOCK: [2017-09-29 Fri 20:31]--[2017-09-29 Fri 21:49] =>  1:18
  CLOCK: [2017-09-29 Fri 11:44]--[2017-09-29 Fri 12:19] =>  0:35
  CLOCK: [2017-09-28 Thu 21:10]--[2017-09-28 Thu 22:40] =>  1:30
  CLOCK: [2017-09-28 Thu 15:18]--[2017-09-28 Thu 15:35] =>  0:17
  CLOCK: [2017-09-28 Thu 13:59]--[2017-09-28 Thu 15:06] =>  1:07
  CLOCK: [2017-09-27 Wed 22:29]--[2017-09-27 Wed 23:48] =>  1:19
  CLOCK: [2017-09-27 Wed 13:23]--[2017-09-27 Wed 14:09] =>  0:46
  CLOCK: [2017-09-27 Wed 11:44]--[2017-09-27 Wed 12:06] =>  0:22
  CLOCK: [2017-09-27 Wed 10:34]--[2017-09-27 Wed 11:22] =>  0:48
  CLOCK: [2017-09-26 Tue 16:05]--[2017-09-26 Tue 16:26] =>  0:21
  CLOCK: [2017-09-25 Mon 21:41]--[2017-09-25 Mon 21:57] =>  0:16
  CLOCK: [2017-09-26 Tue 14:52]--[2017-09-26 Tue 15:48] =>  0:56
  CLOCK: [2017-09-26 Tue 18:02]--[2017-09-26 Tue 18:33] =>  0:31
  CLOCK: [2017-09-26 Tue 21:51]--[2017-09-26 Tue 23:17] =>  1:26
  :END:
  :LOGBOOK:

  :END:

** Week 2 Day One

Our challenge in class was to write a function to rotate a string. Here is a JavaScript implementation:
#+BEGIN_SRC javascript
var s = '123456';
Array.prototype.rotate = function(n) {
var len = this.length;
return !(n % len) ? this.slice()
                  : this.map((e,i,a) => a[(i + (len + n % len)) % len]);
};
console.log(s.split('').rotate(2).join(''));
#+END_SRC

#+BEGIN_SRC emacs-lisp

(rot "Hello my name is" 13)
  

   #+END_SRC

** Week 2 Day Two

*** Q+A
 What is the difference between setf and fset.
 setf is more generic, it means  'set form'
 fset is specific to functions, it means "function set"
 #+BEGIN_SRC emacs-lisp
 (defun fun1 (s y) (* s y))
 (symbol-function 'fun1)
 #+END_SRC

 #+RESULTS:
 | lambda | (s y) | (* s y) |

 #+BEGIN_SRC emacs-lisp :results raw
   (symbol-function 'fun1)
 #+END_SRC

 #+RESULTS:
 nil
 #+BEGIN_SRC emacs-lisp
 (setf (symbol-function 'fun1) (lambda nil (list 1 2 3 )))
 #+END_SRC

 #+RESULTS:
 | lambda | nil | (list 1 2 3) |


*** Hints and Answers
   #+BEGIN_SRC emacs-lisp
   (get-hint 'CRC)
   #+END_SRC 


** DONE DEJ
   CLOSED: [2017-09-28 Thu 14:29]
   :LOGBOOK:
   CLOCK: [2017-09-29 Fri 15:28]--[2017-09-29 Fri 16:16] =>  0:48
   :END:
*** DONE TBD
    CLOSED: [2017-09-28 Thu 14:29]
    A function is injective if and only if is surjective, provided its domain and codomain 
    are the same size. 

** TODO DEK
*** DONE WDK
    CLOSED: [2017-09-29 Fri 14:05]

Variable immutibility
    #+BEGIN_SRC emacs-lisp
(require 'cl)
   (set 'a 'three) 
   (setq a (quote one)) ;; setq is equivalent to set, except instead of having to put a ' in front of the variable, it does it for you
   (setf b '(one two)) ;; setf is similar to setq, but it accepts forms on the left side instead of just symbols like (see the third example of setf)
   (setf a (first b)) ;; whenever you use setq, you could theoretically use setf, although stylisticly, setq is preferred for basic symbols. 
   (setf (second b) a)

(print a)

    #+END_SRC

    #+RESULTS:
    : one
    t
*** DONE TDR
    CLOSED: [2017-09-28 Thu 10:59]

I took an example code block and used it to play with this.
#+BEGIN_SRC emacs-lisp
;;(fset 'test (lambda (n) (if (evenp n) (/ n 2) (+ 1 (* 3 n)))))
(setf (symbol-function 'test) (lambda (n) (/ n 2) (+ 1 (* 3 n))))
(test 7)

#+END_SRC

#+RESULTS:
: 22

*** WDT
PVP = Predict Verify Ponder

**** Predict  

***** 1. I think the first expression will execute without a problem, returning the number 6.

***** 2. I think the second expression will have some trouble, because d is not defined.

***** 3. I think this will run into the same problem, because it is a vector

***** 4. I don't believe that lisp supports operator overloading, so I believe the 4th will fail.

***** 5. I think that this expression will have trouble evaluating, because let process the expressions in parallel, and not sequentially.

***** 6. I think this should give a proper output of 11
 
**** Verify/Ponder

***** Expression 1:
      #+BEGIN_SRC emacs-lisp
 (let ((a 1) (b 2) (c 3)) (+ a b c))
      #+END_SRC

      #+RESULTS:
      : 6
I successfully predicted the result.

***** Expression 2:
#+BEGIN_SRC emacs-lisp
  (let ((a 1) (b 2) (c 3)) (+ a b c d))
#+END_SRC

Returned an error saying that d was void

***** Expression 3: 
#+BEGIN_SRC emacs-lisp 
  (let ((a 1) (b 2) (c 3)) [+ a b c d])
#+END_SRC

#+RESULTS:
: [+ a b c d]

I was not expecting this, but I believe I understand why this happened. Reading this stack overflow post
helped me better understand how vectors work: https://stackoverflow.com/questions/4294346/difference-between-lists-and-arrays

***** Expression 4: 
#+BEGIN_SRC emacs-lisp
  (let ((a 1) (b 2) (c 3) (+ 4)) (+ a b c +))
#+END_SRC

#+RESULTS:
: 10

I found this very interesting. I did not know that 1, you could redefine operators like that. A key point here though, 
if I am correct, it is not actually overloading the operator, but saying 'if you find a + that is not the first element in a list, 
evaluate it as 4'. That's why (+ a b c +) works. Lisp reads the first item as the function to call, and evaluates the second + as 
was previously defined. 

***** Expression 5: 
#+BEGIN_SRC emacs-lisp
  (makunbound 'a)
(let ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))
#+END_SRC

This returned a message saying that a was void. I believe this is due to my reasoning above, 
but my knowledge of Lisp is not currently strong enough to be sure. 

***** Expression 6:
#+BEGIN_SRC emacs-lisp 
  (let* ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))
#+END_SRC

#+RESULTS:
: 11

I successfully predicted the output for this.

*** TEH
    I think that it would be possible. If you made sure to define variables before using them. Let's look at
    a modified version of the example code: 
#+BEGIN_SRC emacs-lisp
;; here's the original statement:
;;(let ((a 1) (b 2) (c 3) (d (+ a 4))) (+ a b c d))

;; let's try to change it up a bit
(let ((a 1) (b 2) (c 3))
   (let ((d (+ a 4))) (+ a b c d)))

;; I nested the let statement that defines d and adds all the variables together
;; inside the first let statement. This ensures that a is given a value before
;; trying to use it to initialize d
#+END_SRC

#+RESULTS:
: 11
*** WFC
    They behave pretty much how I would expect them to. I haven't
    seen anything that raises an eyebrow. It was important to note that
    if you with to use a combination of operators, you must nest them inside
    parantheses. Here's an FLA for you, LISP: Lots of Irritating Single Parantheses ;)

#+BEGIN_SRC emacs-lisp
(/ 24 4 3)
(* 5 4 3 2 1)
(* (+ 2 3) 2)
#+END_SRC

#+RESULTS:
: 10

Even with multiple operands, it behaves exactly as expected. It executes the operation in the order it was given. 
*** TEJ
**** assoc-string
     when using assoc-string, the key must be a string or symbol.
    
   #+BEGIN_SRC emacs-lisp
  (defun lookup-rgb (color-name)
  (rest (assoc-string color-name
               '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))))

  (lookup-rgb "green")
   #+END_SRC 

   #+RESULTS:
   | 0 | 255 | 0 |
**** rassoc
rassoc is like the reverse assoc. Instead of searching for the car, it matches the cdr
    #+BEGIN_SRC emacs-lisp
   (defun lookup-rgb (color-range)
  (rest (rassoc color-range
               '(("red" 255 0 0) ("green" 0 255 0) ("blue" 0 0 255)))))
;; Produces nil: 
;;(lookup-rgb '(0 255 3))
;; Produces the cdr 
   (lookup-rgb '(255 0 0))
    #+END_SRC 

    #+RESULTS:
    | 255 | 0 | 0 |
**** assq
assq is also similar to assoc, but it compares using eq insteal of equal.
Go here to read the difference: https://www.gnu.org/software/emacs/manual/html_node/elisp/Equality-Predicates.html#Equality-Predicates
assq is best used when the key is a symbol, not a string

#+BEGIN_SRC emacs-lisp
   (defun lookup-rgb (color-range)
  (rest (assq color-range
               '((red 255 0 0) (green 0 255 0) (blue 0 0 255))))) 
(lookup-rgb 'red)
#+END_SRC

#+RESULTS:
| 255 | 0 | 0 |
**** more
     There are several more variations of assoc. You can find them here: https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html
*** DONE WFK
    CLOSED: [2017-09-29 Fri 15:39]
Removing the :test 'equal changes the the contents of the pretty print list to nil, as eq does not work on string literals
#+BEGIN_SRC emacs-lisp :results output
(let* ((mymap (make-hash-table :test 'equal)))
  (puthash "one" "red" mymap)
  (puthash "two" "blue" mymap)
  (puthash "three" "green" mymap)
  (pp (list (gethash "one" mymap)
            (gethash "two" mymap)
            (gethash "three" mymap)))
  (maphash (lambda (key value) (princ (format "%s : %s\n" key value))) mymap))

#+END_SRC

#+RESULTS:
: ("red" "blue" "green")
: one : red
: two : blue
: three : green
*** TER
**** Predict
     This looks similar to the map function in JavaScript, which is given an array, and executes a function
     on each element in the array. (See here for more info on JS map https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
     I would assume that morphify does something similar. Guessing from the function call to downcase, I think
     it will put each word as lowercase. 
**** Verify/Ponder
#+BEGIN_SRC emacs-lisp
(defun morphify (fun lst)
  (loop for item in lst
        collect (funcall fun item)))
(morphify (quote downcase) (quote ("THIS" "IS" "TOO" "LOUD")))
#+END_SRC

#+RESULTS:
| this | is | too | loud |
**** Part 2
#+BEGIN_SRC emacs-lisp
(defun morphifyr (fun lst)
  (if (null lst)
      nil
    (append (list (funcall fun (first lst))) (morphifyr fun (rest lst)))))

(morphifyr 'upcase '("1232142" "asdfasdf" "abcdefg"))
#+END_SRC

#+RESULTS:
| 1232142 | ASDFASDF | ABCDEFG |

First this function checks that there was a function passed to it. If not, it returns nil
Next it starts appending a list. The first element of this list is created by calling the passed function on the
car. It builds the rest of the list by calling morphify on the cdr. This recursively builds the list items and returns
a new list, thus keeping it functional!
*** WGP 

Just use the example given in the miniprimer! Append an empty list to a vector to convert it to a list.

    #+BEGIN_SRC emacs-lisp
    (defun vector-to-string(vec)
      (append vec nil))

(format "%s" (vector-to-string [a b c]))

    #+END_SRC

    #+RESULTS:
    : (a b c)
*** TODO TEU


17316


#+BEGIN_SRC javascript
// A function that counts solutions for a given predicate. 
// Takes a max number of iterations, as well as a predicate. 
// There is an optional third parameter, min, if you do not 
// wish to start counting at zero
function countSolutions(max, pred, min = 0) {
  let counter = 0;
  for (let i = min; i < max; i++) {
     pred(i) ? counter++ : null;
  }
  console.log("total",counter);
}


function teu_loops(i) {
  let val = i,
      sum = 0, 
      ones = 0;
  
  while (val) {
    if (ones > 1) {
      return false;
    }
    if (val % 10 === 1) {
      ones++;
    }
    sum += val % 10;
    val = Math.floor(val / 10);
  }
  if (sum != 17){
    return false;
  }
  return true;
}
countSolutions(1000000,teu_loops);
#+END_SRC


A non-looping solution
#+BEGIN_SRC javascript
const print = console.log

// A function that counts solutions for a given predicate. 
// Takes a starting, and max number, as well as a predicate. 
// The function also takes a count of how many times the predicate
// returns true. 
function tellen(start, max, pred, tel=0) {
  if(start >= max) {
    return tel;
  }
  pred(start) ? tel++ : null;
  return tellen(start + 1, max, pred, tel)
}

function sumDigits(number) {
    var remainder = number % 10;
    var sum = remainder;
    if(number >= 10) {
        var rest = Math.floor(number / 10);
        sum += sumDigits(rest); 
    }
    return sum;
}

function lessThanOnes(number) {
  let str = number + '';
  if(str.split('1').length > 2) {
    return false;
  }
  return true;
}

function pred(i) {
  if(sumDigits(i) === 17 && lessThanOnes(i)) {
    return true;
  }
  return false;
}


print(tellen(0,1000000, pred));
#+END_SRC
*** DONE WGW
    CLOSED: [2017-09-28 Thu 14:59]

First it checks that pre is a list and that its length is three. 
Then is creates a variable for each operator, using the nth item in the list function.
To ensure that any nested operations are caught, the prefix->infix function is called again on 
each of the operands. 
    #+BEGIN_SRC emacs-lisp
 (defun prefix->infix (pre)
  (cond ((listp pre)
         (or (= 3 (length pre)) (error "not a 3-length list"))
         (let ((operator (nth 0 pre))
               (operand1 (nth 1 pre))
               (operand2 (nth 2 pre)))
           (list (prefix->infix operand1)
                 operator
                 (prefix->infix operand2))))
        (t pre)))   
(prefix->infix '(/ 1.0 (* (+ (* 2 n) 1) (expt -1 n))))
    #+END_SRC

    #+RESULTS:
    | 1.0 | / | (((2 * n) + 1) * (-1 expt n)) |

#+BEGIN_SRC emacs-lisp
(defun prefix->infix (pre)
   (if (listp pre)
     (if (= 3 (length pre)) 
        (list 
         (prefix->infix (nth 1 pre))
         (nth 0 pre)
         (prefix->infix (nth 2 pre)))
         (error "not a 3-length list"))
      (list pre)))

(prefix->infix ')(* (/ 12 4 )(+ 3 2))

#+END_SRC

#+RESULTS:
| ((12) / (4)) | * | ((3) + (2)) |
*** TFV
#+BEGIN_SRC emacs-lisp
    
(defun infix->prefix (in)
       (cond ((listp in) (or (= 3 (length in)) (error "not a 3-length list"))
         (let ((operand1 (nth 0 in)) (operator (nth 1 in)) (operand2 (nth 2 in)))
                (list operator (infix->prefix operand1)
                 (infix->prefix operand2))))
        (t in)))
(infix->prefix '((3 * 7) + 4))
#+END_SRC

#+RESULTS:
| + | (* 3 7) | 4 |
** DONE DEL
   CLOSED: [2017-09-29 Fri 15:56]
*** WJS

Because the floor function takes the largest integer less than or equal, and the number is negative, the next lowest integer will be -x - 1. In positive division, this is 
the same effect as integer division, because if there is a decimal remainder, it will be chopped off, leaving the next lowest integer. Because negative numbers are moving
the opposite direction, you can almost imagine floor and ceiling also get negated respectively. The floor of a negative x is the ceiling of the absolute value of x, and vice versa.
*** TGE
#+BEGIN_SRC emacs-lisp
(defun compute-floor-the-hard-way (dividend divisor)
  (- (/ dividend (float divisor)) (/ (mod dividend divisor) (float divisor))))

(let* ((number (/ -13 4.0))
       (floor1 (floor number))
       (floor2 (compute-floor-the-hard-way -13 4.0)))
  (list number floor1 floor2))
#+END_SRC

#+RESULTS:
| -3.25 | -4 | -4.0 |

I'm not sure exactly what is meant by 'correct', but the compute-floor-the-hard-way returns a floating point number, not an integer,
so one could make the argument that it is not correct, as floor should return an integer.    
*** WKC
    #+BEGIN_SRC emacs-lisp 
  (defun frac-part (number)
  (- number (floor number)))

(print (frac-part 3.14159))

(defun floor2 (number)
"returns the floor of a number using the provided frac-part function defined above"
(truncate (- number (frac-part number))))

(print (floor2 3.14159))


#+END_SRC

#+RESULTS:
: 3
*** DONE THP
    CLOSED: [2017-09-29 Fri 15:56]

FLOOR
                 5
                    |              *--o
                    |           *--o
                    |        *--o
                    |     *--o 
                    |  *--o 
-5   ---------------*--o----------------5
                 *--o
              *--o  |
           *--o     |
        *--o        |
     *--o           |
                   -5

CEILING

                 5
                    |              o--*
                    |           o--*
                    |        o--*
                    |     o--* 
                    |  o--* 
-5   ---------------o--*----------------5
                 o--*
              o--*  |
           o--*     |
        o--*        |
     o--*           |
                   -5

*** WKM
**** 1. True
**** 2. True
**** 3. False
**** 4. True
**** 5. True
**** 6. True
**** 7. True
**** 8. False
**** 9. True
**** 10. True
*** TIW
    #+BEGIN_SRC emacs-lisp
(defun frac-part (number)
  (- number (floor number)))

(defun round-nearest-int (number)
   (cond 
      ((< (frac-part number) .5) (floor number))
      (t (ceiling number))
   )
)   

(round-nearest-int '1.5624) 
    #+END_SRC

    #+RESULTS:
    : 2
** DEM 
*** WNW
    An invertible function must be one-to-one. 
*** TKG
#+BEGIN_SRC emacs-lisp 
 (setq values '((x . 100) (y . 200) (z . 50)))
 (assoc 'y values)
 (rassoc '100 values)
 
#+END_SRC 

#+RESULTS:
: (x . 100)

Assoc searches by key, rassoc searches by value
An associative list is a kind of hash mapping, where each value is given a key. This creates
a one-to-one relationship which is why assoc can be inverted with rassoc.  
** DEN
*** DONE WOV
    CLOSED: [2017-10-06 Fri 10:50]
    1. a, a + d, a +2d, a + 3d... where a = 7 d = 7
    2. a, a + d, a + 2d, a + 3d... where a = 7 d = 4
    3. a, a + d, a + (d + 1), a + (d + 2), a + (d + 3) where a = 3 d = 1
    4. it is binary addition, adding one each iteration starting with 1.
    5. Fibonacci, n = n - 1 + n - 2 where n is the index in the sequence
    6. Starting with index 2, every other number is half of the one previous. ****
    7. Alternative fibonacci pattern beginning with 2,1 instead of 1, 1
    8. multiply the last index by two to find the next entry in the sequence. Where n initial is 6
    9. multiply the last index by three to find the next entry in the sequence. Where n intial is 6
    10. A sequence of prime numbers
*** TME
   This sequence is building the title of the book, Metaphors Be With You: 
   A Tireless Work On Play On Words. After 4 iterations, it adds a new letter
   to each item, spelling out the title.
   [metaph bewith youat irele metapho bewithy ouatir elessw] etc... 
** DONE DEO
   CLOSED: [2017-10-03 Tue 18:13]
*** DONE WQW
    CLOSED: [2017-10-06 Fri 10:50]
    | Predicate | Yes or No? |
    |-----------+------------|
    | list      | no         |
    | listp     | yes        |
    | integerp  | yes        |
    | vector    | no         |
    | vectorp   | yes        |
    | symbolp   | yes        |
    | zerop     | yes        |
    | evenp     | yes        |
    | oddp      | yes        |
    |           |            |
*** DONE TMZ
    CLOSED: [2017-10-03 Tue 18:13]
**** 1.
 #+BEGIN_SRC emacs-lisp :results raw
 (require 'cl)

 (defun count-gcd (max pred)
 (let ((counter 0)))
 (loop for i from 1 to max 
    sum (loop for j from 1 to max
       count (funcall pred i j))))

 (count-gcd 1000 (lambda (m n) (= 1 (gcd m n))))
 #+END_SRC

 #+RESULTS:
 608383
**** 2.  
There are infinitly many solutions to this problem as given. ax + by = c is what is known as a 
Diophantine equation. One of the rules of these equations is that if c is a multiple of the gcd(a,b), than
there are is an infinite amount of solutions. 
For the given problem where a = 3, b =4 , c=7: 
#+BEGIN_SRC emacs-lisp :results raw
(gcd 3 4)
#+END_SRC 

#+RESULTS:
1

7 is a multiple of 1, therefore, this equation does have a solution (for example, x = 1, y = 1), but it also 
implies that there is an infinite set of solutions. See http://mathforum.org/library/drmath/view/51595.html for a more
detailed explanation. 
**** 3.
#+BEGIN_SRC javascript
function checkSet(set, pred) {
  let count = 0;
  for(let i = set[0]; i < set.length; i++) {
    for (let j = set[0]; j < set.length; j++) {
      if (pred(i, j)) {
        count++;
      }
    }  
  }
  return count;
}
const set = [2,3,4,5,6,7,8,9]
console.log(checkSet(set, (i, j)=>{return ((j * i) - 1) % 11 === 0}));
#+END_SRC

If I did this correctly, there are 4.
**** 4. 
#+BEGIN_SRC javascript
// using the same function as above...
const set = [2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10 ,11 ,12 ,13 ,14 ,15 ,16 ,17 ,18, 19, 20, 21];

console.log(checkSet(set, (i, j)=>{return ((j * i) + 1) % 23 === 0}));

#+END_SRC

There are 16 pairs. 
**** 5.  
#+BEGIN_SRC javascript
// using the same checkSet function...
const set = [2,3,4,5,6,7];
console.log(checkSet(set, (i, j)=>{return ((j * i) + 1) % 9 === 0}));
#+END_SRC

** DONE DEP
   CLOSED: [2017-09-29 Fri 21:07]
*** DONE WRA
    CLOSED: [2017-09-29 Fri 21:07]
There is an elegent proof that can be found that demonstrates that 1/2 + ... 1/2^n is a convergent series. I could explain it here, 
but I fear I would not do it justice, however, I will attempt to put it in my own words. You can find a complete proof here -> https://www.quora.com/How-does-1-2-+-1-4-+-1-8-+-1-16-+-%E2%80%A6-till-infinity-have-a-sum

We know that because we are dealing with fractions, an infinite sum of smaller and smaller pieces will eventually approach a limit of some number. 
We can for all intents and purposes call this limit the sum, as given an infinite amount of iterations, it will would reach it. This is why some infinite series
can have finite sums. I encourage you to read the full proof, as it can explain it much better than I can; I am not a mathematician yet \smiley.
*** TNL
    The counterpart of \sum is \Pi or Pi (uppercase) The notation is the same
as sigma, but the terms are multplied instead of added. 
*** DONE WRD
    CLOSED: [2017-09-29 Fri 20:40]
    :PROPERTIES:
    :ORDERED:  t
    :END:
#+BEGIN_SRC emacs-lisp
(require 'cl)

(loop for i from 0 to 10
   sum (loop for j from i to 5
      sum (* j 2 i)))


(loop for i from 0 to 10
   sum (loop for j from 0 to i
      sum (* i (+ 5 (- i j))))) 


#+END_SRC

#+RESULTS:
: 490

*** TNQ

I found the measure-time macro on an elisp mailing list \smiley 
    #+BEGIN_SRC emacs-lisp
    (defmacro measure-time (&rest body)
  "Measure the time it takes to evaluate BODY."
  `(let ((time (current-time)))
     ,@body
     (message "%.06f" (float-time (time-since time)))))

(defun calculate-pi-very-slowly (max-iterations)
  (* 4 (loop for n from 0 to max-iterations
             sum (/ 1.0 (* (+ (* 2 n) 1) (expt -1 n))))))

;(measure-time (calculate-pi-very-slowly 5000000))
 (calculate-pi-very-slowly 5000000)

    #+END_SRC

    #+RESULTS:
    : 3.1415928535897395

Based on the approach that this method is using, and considering the fact that \pi is an irrational number, 
I'm not convinced that this will EVER give you pi. It would take an infinite amount of iterations. Just to get
to the point above took about a minute and 20 sec on a pretty powerful laptop, and it's still not even accurate 
past 10^-6 power. 

** DONE DEV
   CLOSED: [2017-10-06 Fri 21:43]

*** WRP
   
**** âˆƒ x P(x)
     There exists in x such that x is 21
**** âˆ€ x P(x)
     Every person the domain of all people is 21
**** âˆƒ x Â¬ P(x)
     There exists in x such that someone is NOT 21
**** âˆ€ x Â¬ P(x)
     No person is 21
*** TOJ
**** âˆƒ x S(x)
There are residents of Idaho who are students at BYU-Idaho
**** âˆ€ x S(x)
All residents of Idaho are students at BYU-Idaho
**** Â¬âˆƒ x S(x)
There are no residents of Idaho who are students at BYU-Idaho
**** âˆƒ x Â¬ S(x)
There are residents of Idaho who are not students at BYU-Idaho
**** Â¬âˆ€ x Â¬ S(x)
Some residents of Idaho are BYU-Idaho students
**** âˆ€ x Â¬ S(x)
No residents of Idaho are BYU-Idaho students
*** WRU
**** âˆ€ x (F(x) â†’ C(x))
Every friend is cool
**** âˆƒ x (F(x) âˆ§ C(x))
There are friends that are cool
**** âˆ€ x (F(x) âˆ§ C(x))
In the reading, it says that this should be written as  âˆ€ x (F(x) â†’ C(x))
which means that every friend is cool
**** âˆƒ x (F(x) â†’ C(x))
This is also expressed incorrectly according to section DEV, it should be
 âˆƒ x (F(x) âˆ§ C(x)) which means that there are friends that are cool
*** TOL
**** âˆ€ x (S(x) â†’ R(x))
All students are from Russia
**** âˆƒ x (R(x) â†’ R(x))
Should be written as  âˆƒ x (S(x) âˆ§ R(x))
There are students who are from Russia
See DEV
**** âˆ€ x (S(x) âˆ§ R(x))
Should be written as  âˆ€ x (S(x) â†’ R(x)) See DEV
and means All students are from Russia
**** âˆƒ x (S(x) âˆ§ R(x))
There are students who are from Russia
*** WZO
**** Everyoneâ€™s a critic.
     \forall x (S(x)) where S(x) = x is a critic and the domain is all people
**** No one is perfect.
     \forall x \not (S(x)) where S(x) = x is perfect and the domain is all people
**** At least one of your friends is perfect.
     \exists x (S(x)) where S(x) = x is perfect and the domain is friends
**** All of your friends are critics.
     \forall x (S(x)\rightarrow C(x)) where S(x) = x is your friend and C(x) = x is a critic and the domain is all people
**** Everyone is a critic or someone is your friend.
    \forall x (C(x))\vee \exist x (S(x)) where C(x) = x is a critic and S(x) = x is your friend
**** No one is a critic and everyone is your friend.
     \not \exists x (C(x)) \wedge \forall x (S(x)) where C(x) = x is a critic and S(x) = x is your fr
*** TOUc
**** All horses have hooves
     \forall x (H(x)->h(x)) where H(x) = x is a horse and h(x) = x has hooves
     \exists X (H(x) V \not h(x))
     
     There exists a horse that does not have hooves
**** No horses can fly
     \forall x (H(x)->f(x)) where H(x) = x is a horse and f(x) = x cannot fly
     \exists x (H(x) V \not f(x)) 
     There exist some horses who can fly. 
**** Every bat is blind
     \forall x (B(x)->b(x)) where B(x) = x is a bat, and b(x) = x is blind
     \exists x (B(x) V \not b(x))
     There exists a bat which is not blind
**** TODO No bear can dance
     \forall x (B(x)->d(x)) where B(x) = x is a bear and d(x) = x can't dance
     \exists x (B(x) V \not d(x)) 
      There exists a bear which can dance. 
**** There is at least one penguin that can swim and catch fish
    \exists x (P(x) \wedge S(x)\wedge C(x) )  S(x) = x can swim and C(x) = x can catch fish
    \forall x (\not P(x) V \not S(x) V \not C(x)) 
    There are no pengiuns that can swim or catch fish
* Week 3 DEF PT2 
  :LOGBOOK:
  CLOCK: [2017-10-06 Fri 16:20]--[2017-10-06 Fri 17:53] =>  1:33
  CLOCK: [2017-10-06 Fri 10:44]--[2017-10-06 Fri 11:15] =>  0:31
  CLOCK: [2017-10-05 Thu 22:03]--[2017-10-05 Thu 23:33] =>  1:30
  CLOCK: [2017-10-05 Thu 20:22]--[2017-10-05 Thu 21:26] =>  1:04
  CLOCK: [2017-10-05 Thu 14:52]--[2017-10-05 Thu 15:42] =>  0:50
  CLOCK: [2017-10-03 Tue 19:10]--[2017-10-03 Tue 20:36] =>  1:26
  CLOCK: [2017-10-03 Tue 16:00]--[2017-20-03 Tue 18:15] =>  2:15 
  :END:
** Week 3 Day One
*** Remedies   
*** Do Hard Things
**** Let and Lambda
** Week 3 Day Two   
*** In class exercise
**** Code
   #+BEGIN_SRC emacs-lisp
   (get-answer 187434316 'ujf)
   #+END_SRC

   #+RESULTS:
     The limiting radius (r_\infty) of the outermost circle is 8.700
     (approximately).

     There are reasons finding the value of this radius is an exercise/problem in
     /discrete/ mathematics (one is because algorithms are step-by-step discrete
     things, another is that the answer can only be given with finite precision,
     which is a discrete math idea) and there are reasons for it being /continuous/
     mathematics (because you can do it without a computer, and the answer is a
     /real/ number, which is a continuous math idea). In other words, it depends!

     Whether or not this was an exercise (versus a problem) depends on if on first
     contact you immediately knew how to answer it or not!

     Below are two computational solutions to this problem, one in C++, one in
     elisp. A good exercise of your thinking and writing skills would be to compare
     and contrast the two, bearing in mind that to be responsive at all there
     should be at least one point of comparison (telling how they are the same) and
     at least one point of contrast (telling how they are different), and
     preferably two or more of each.

     

    #+BEGIN_SRC C++ :var num=10000000 :results output
      #include <iostream>
      #include <iomanip>
      #include <cmath>
      #include <ctime>
      #include <cstdlib>
      using namespace std;

      double limitingRadius(long numSides)
      {
         double radius = 1.0;
         for (long i = 3; i < numSides; i++)
         {
            radius /= cos(M_PI / i);
         }
         return radius;
      }

      int main(int argc, const char* argv[])
      {
         int n = (argc < 2) ? num : atol(argv[1]);
         clock_t start = clock();
         double result = limitingRadius(n);
         clock_t end = clock();
         cout << "Calculated " << setprecision(17) << result
              << " with " << num << " iterations in "
              << (end - start) / (double) CLOCKS_PER_SEC
              << " seconds.\n";
         return 0;
      }
    #+END_SRC

    #+RESULTS:

    #+BEGIN_SRC emacs-lisp :results raw
      (defun limiting-radius (num-sides)
        (loop with result = 1.0
              for i from 3 below num-sides
              do (setq result (/ result (cos (/ pi i))))
              finally return result))

      (defun calculate-limiting-radius (num-sides)
        (let* ((start (float-time))
               (result (limiting-radius num-sides))
               (end (float-time)))
          (format "Calculated %.17f with %d iterations in %.17f seconds."
                  result num-sides (- end start))))
    #+END_SRC

    #+RESULTS:
    calculate-limiting-radius

    #+BEGIN_SRC emacs-lisp
      (calculate-limiting-radius 100000)
    #+END_SRC

    #+RESULTS:
    : Calculated 8.69960730405618676 with 100000 iterations in 0.54544758796691895 seconds.

    #+BEGIN_SRC emacs-lisp
      (calculate-limiting-radius 1000000)
    #+END_SRC

    #+RESULTS:
    : Calculated 8.69999369233345732 with 1000000 iterations in 0.36726808547973633 seconds.

    #+BEGIN_SRC emacs-lisp
      (calculate-limiting-radius 10000000)
    #+END_SRC

    #+RESULTS:
    : Calculated 8.70003233192909420 with 10000000 iterations in 3.98808026313781738 seconds.

    #+end_example

**** Similarties
***** The algorithm is essentially the same in lisp and C++. The limited radius is calculated dividing the radius by cosine of pi over the iteration. 
***** They are both calculating the result procedurally with a for loop instead of recursively (which would be more functional)
**** Differences
***** elisp is much more verbose than c++. Consider the for loop. The for loop in elisp is written very similarly to how you 
      would explain a for loop to someone who is unfamiliar with the concept.
***** C++ is taking the number of iterations from the command line arguments, while elisp is using a function call with parameter. 
***** C++ has to include several more libraries, while they are included in elisp
***** C++ is strongly typed, while elisp variables are 'dynamic'
** DONE DEV
   CLOSED: [2017-10-06 Fri 16:28]
   :LOGBOOK:
   CLOCK: [2017-10-05 Thu 22:02]--[2017-10-05 Thu 22:03] =>  0:01
   :END:
*** WYH
**** 1. 
     \exists x (C(x) \wedge a(x)) where x is a song C(x) = x can be sung a(x) = there is a soul alive
**** 2.
     \forall x (m(x)) where x the set of all errors m(x) = displays an error
**** 3.
     \exists x (P(x) \wedge V(x)) where x is the set of scanned programs. P(x) = x is a program, V(x) = x has a virus
*** TLI
    1. False. There are many integers greater than
    2. True.
    3. True.
    4. False
*** DONE WPI
    CLOSED: [2017-10-06 Fri 16:28]
    1. True
    2. False
    3. True
    4. True
*** TSD
1. \exists x (E(x) \wedge \not L(x) \wedge \not R(x))
2. \exist x (L(x) \wedge R(x))
3. \exists x (E(x) \wedge \not R(x))
4. \exists x (E(x) \wedge L(x))
*** WTM
    1. \not \exists x (L(x) \wedge D(x))
    2. \forall x (S(x)->D(x))
    3. \forall x (F(x) -> L(x))
    4. \not \exists (F(x)\wedge S(x))
    5. Yes it does.
*** TTV
    1. True cube root of -9 is approx -2.08
    2. True
    3. True
    4. True
*** DONE WUZ
    CLOSED: [2017-10-06 Fri 16:20]
    :LOGBOOK:
    CLOCK: [2017-10-06 Fri 16:20]--[2017-10-06 Fri 17:53] =>  1:33
    :END:

#+BEGIN_SRC emacs-lisp :results raw
(defun is-true-even (x)
   (= 0 (% x 2)))

(defun is-false-even (x)
   (not (is-true-even x)))

(defun is-true-odd (x)
   (not (is-true-even x)))

(defun is-false-odd (x)
   (is-true-even x))

(defun for-all (set func)
   (loop for i in set
      always (funcall func i)))

(defun for-some (set func)
   (loop for i in set
      thereis (funcall func i)))

(for-all '(3 1 7 8) 'is-true-even)

#+END_SRC

#+RESULTS:
nil
t
t
nil

** DEW
*** WZM
**** Injective
     \forall a,b \in X
**** Surjective
     \forall y \in \exists x \in X 
*** TUK 
**** 1. âˆƒ x âˆ€ y (x > y)
     There exists an X that is greater than all y. False?
**** âˆƒ x âˆƒ y (((x â‰¥ 0) âˆ§ (y â‰¥ 0)) â†’ (xy â‰¥ 0))
     There exists an x and a y that if x is greater than or equal to 0  and y is greater than or equal to zero, then x multiplied by y is greater than zero. This is true.
****  âˆƒ x âˆ€ y âˆƒ z (x = y + z)
     There exists an x and z for all y that x equals y plus z.
*** WVQ
Let Q(x, y) be the statement â€œx asks y a question,â€ where the domain for both x and y consists of all students in a class. Express each quantification in an English sentence.
**** 1. âˆ€ x âˆƒ y Q(x, y)
    All students ask at least one other student a question in a class 
**** 2. âˆ€ x âˆ€ y Q(x, y)
     All students ask all other students a question in a class
**** 3. âˆƒ x âˆƒ y Q(x, y)
     Some students ask some other students a question in class
**** 4. âˆƒ x âˆ€ y Q(x, y)
     Some students ask all other students a question in class
**** 5. âˆ€ y âˆƒ x Q(x, y)
     All students are asked a question by some students in a class
**** 6. âˆƒ y âˆƒ x Q(x, y)
     Some students are asked a question by some students in the class
*** DONE TUQ
    CLOSED: [2017-10-06 Fri 16:36]
**** 1.
     \not \forall x \forall y Q(S(x),T(y))
**** 2. 
     \exists x \exists y Q(S(x), T(y))
**** 3. 
     \forall x \exists y (Q(S(x), T(y))) \wedge (Q(S(x), A(x)))
**** 4. 
     \exists x \exists y Q((S(x) \wedge (x \ge 2)), T(y))
*** WVU 
    x is a teacher and y is a class
**** 1. 
     \not\exists x \forall y T(x, y)
**** 2.
     \forall x \forall y T(x, y)
**** 3.
    \exists x \forall y (T(x, y) \wedge (x \ge 2) 
**** 4.
    \not \exists x \forall y T(x, y)
*** DONE TUW
    CLOSED: [2017-10-06 Fri 17:22]
    1. Every CS Major needs to take discrete mathematics
       T(x,y) = x must take y
       C(x) = x is a computer science major
       \forall x (C(x)-> T(x, Discrete Math))
    2. Every student in the class owns a laptop 
       domain is student in the class
       O(x, y) x owns y. 
       \forall x O(x, laptop)
    3. There is a student in the class that has taken data structures.
       D(x,y) = x has taken y
       \exists x D(x, Data Structures)
    4. No student has been in every building at the University
       The domain is all students and buildings at the University.
       F(x, y) x has been in y S(x) x is a student B(x) x is a building
       \not \forall x \forall y F(S(x), B(x))
    5. Exactly one student has been in every room in the STC
       The domain is all students and buildings
       F(x,y) x has been in y. S(x) x is a student B(x) x is the STC
       \exists! x F(S(x), B(x))
    6. \forall x \exists y \forall z F(x,y,z) x has been in room y in building z 
*** WWD
*** TVL
    1. Jackon Andrews dropped out of Discrete Mathematics.
    2. There is a student who has dropped out of all classes
    3. All students have dropped out of a class
*** WWR
    1. \forall x \exists y ( (x + y)/2 <= x <= y) )
    2. \forall x \forall (x * -y < 0)
    3. \not \exists x F(x) where F(x) = x can be divided by 0
    4. \forall x (F(x) > 0) where F(x) = x is a positive number
*** TWN
    \not \exist x P(x)\wedge F(x) P(x) x is a prime number and F(x) = x has 3 factors
*** WWS 
    1. True
    2. True
    3. True
    4. True
*** TXG
    1. True
    2. False
    3. True
    4. True
    5. True
    6. False
    7. False
    8. True
*** WZG
    1. All real numbers
*** DONE TKH
    CLOSED: [2017-10-06 Fri 21:37]
#+BEGIN_SRC emacs-lisp :results raw
(defun is-true-even (x)
   (= 0 (% x 2)))

(defun is-false-even (x)
   (not (is-true-even x)))

(defun is-true-odd (x)
   (not (is-true-even x)))

(defun is-false-odd (x)
   (is-true-even x))

(defun for-all (set func)
   (loop for i in set
      always (funcall func i)))

(defun for-some (set func)
   (loop for i in set
      thereis (funcall func i)))

(defun for-all-for-all (x y pred)
   (loop for i in x
     always (loop for j in y
         always (funcall pred i j))))

(defun for-some-for-some (x y pred)
    (loop for i in x
       thereis (loop for j in y
          thereis (funcall pred i j))))

(defun for-all-for-some (x y pred)
    (loop for i in x
        always (loop for j in y
           thereis (funcall pred i j))))

(defun for-some-for-all (x y pred)
   (loop for i in x
      thereis (loop for j in y
         always (funcall pred i j))))

(defun x-greater-y (x y)
(> x y))

;;(for-all '(3 1 7 8) 'is-true-even)
;;(for-all-for-all '(9 9 9 9 9 9) '(10 2 3 4 5 6 7) 'x-greater-y)
;;(for-some-for-some '(1 2 3 4) '(5 1 7 8) 'x-greater-y)

#+END_SRC   

#+RESULTS:
t
nil
nil
nil
t


*** WUE
    âˆ€xâˆƒyP(x,y)

    Stated in English this would say that for all blessings x there exists a law y.
    This is almost identical to how the scripture is worded. 

* Week 4 GHI
  :LOGBOOK:
  CLOCK: [2017-10-14 Sat 12:21]--[2017-10-14 Sat 12:53] =>  0:32
  CLOCK: [2017-10-13 Fri 20:55]--[2017-10-13 Fri 22:09] =>  1:14
  CLOCK: [2017-10-13 Fri 20:04]--[2017-10-13 Fri 20:18] =>  0:14
  CLOCK: [2017-10-12 Thu 21:38]--[2017-10-12 Thu 22:01] =>  0:23
  CLOCK: [2017-10-12 Thu 18:18]--[2017-10-11 Thu 18:46] =>  0:28
  CLOCK: [2017-10-11 Wed 20:42]--[2017-10-11 Wed 22:50] =>  2:08
  CLOCK: [2017-10-10 Tue 21:09]--[2017-10-10 Tue 22:19] =>  1:10
  CLOCK: [2017-10-10 Tue 15:53]--[2017-10-10 Tue 17:17] =>  1:24
  :END:

** Week 4 Day One

*** Discuss DeMorgan's Laws
    
**** For Propositional Logic
     
     A negation of a disjunction/conjuction \equiv conjunction/disjunction of the negations


***** How do you negate a conditional? (p -> q)?
      
      (p \rarr q) \equiv \not p \lor q
      \not (p \rarr q) \equiv \not (\not p \lor q) \equiv (p \wedge \not q)
      
**** For Quantfiers
     
***** A Small Universe
      \forall x Even(x)
      
      Consists of two elements:  [2, 4]
      \forall x Even(x) \equiv Even(2) \wedge Even(4) ...

      \forall x Even(x) \equiv Even(2) \land Even(4)

      \not \forall Even(x) \equiv \not (Even(2) \land Even(4)) \equiv \not Even(2) \lor \not Even(4)

      \exists x \not Even(x) \equiv \not Even(2) \lor \not Even(4)

      \exists x LessThan(x, 4) \equiv lessThan(2, 4) \lor lessThan(4,4)

      \not \exist x LessThan(x, 4) \equiv \not (lessThan(2, 4) \lor lessThan(4,4)) \equiv \not LessThan(2, 4) \land \not LessThan(4,4) \equiv \forall x \not LessThan(x,4)

      Not All  does not mean not none, it means some not. 
      Not Some does not mean All. It means All Not, or none. 

***** What Say

      
****** Axioms of Real Numbers
       
       - Trichotomy \rarr one (and only one) of these three statements is true:
         * x < y
         * x = y
         * x > y

           x < 0 means x is a negative number
           x > 0 means x is a positive number
           x \ge 0 means x is a non-negative number
           x \le 0 means x is a non-positive number
       
****** The product of two negatives is positive

****** The mean of two positive numbers is positive

****** The difference of two negative numbers is negative. False.
       If y is more negative than x, e.g., -4 < -3.

       
******* Negation
        \not \forall x \forall y [(x < 0) \land (y < 0) \rarr (x-y < 0)] \equiv
        \exists x \not \forall y [(x < 0) \land (y < 0) \rarr (x-y < 0)] \equiv
        \exists x \exists y \not [(x < 0) \land (y < 0) \rarr (x-y < 0)] \equiv
        \exists x \exists y [(x < 0) \land (y < 0) \land (x-y \ge 0)]. True. 

*** Questions 
    
**** How many possible binary realtions are there on a set with 3 elements?
     Relation: A binary relation is a SUBSET of A x A (Cartesian product)

     A = [1 2 3] 
     A x A = [ [1 1] [1 2] [1 3] [2 1] ...] 
     if A is size n, then the size of A x A = n^2

     How many subset are there of a set of size m? 2^m

     How many subsets are there of a set with n^2 elements? 2^{n^2}
** Week 4 Day Two
   What does Polyadic mean in the context of functin arity classification?

   I propose that we take it ot mean a function that takes ZERO or more arguments

#+BEGIN_SRC emacs-lisp :results raw append
(list 1 2 3 4 5 3 7)
#+END_SRC

#+RESULTS:
** DONE GHL
   CLOSED: [2017-10-11 Wed 20:51]

*** EBQ
I posted about this in the Slack channel, it was kind of hard to explain without the code, 
so I tried to comment this the best I could. I'm still not a lisp expert, so these comments 
are based on what I understand to be happening based on the documentation that I have read. 
#+BEGIN_SRC emacs-lisp :results silent
(defun cartesian-product (x y)
  (mapcan (lambda (x-item) ;; map over the first list
      (mapcar (lambda (y-item) ;; map over the second list
          (if (listp x-item) ;; check that we are given a list 
            (append x-item (list y-item)) ;; if so, append the y-item 
            (list x-item y-item))) ;; otherwise, list the two items
       y)) ;; passing y into the nested map
   x)) ;; passing x into the map

(defun cartesian-product-general (list-of-sets)
   (reduce #'cartesian-product list-of-sets)) 
;; caling the reduce function on the cartesian-product 
;; reduce will go through the list-of-sets, evaluate the function
;; on the first two, and then evaluate it again with the first result and 
;; the third element so on until it runs out of sets. 

#+END_SRC
#+BEGIN_SRC emacs-lisp
(cartesian-product-general '((a b c d e f g h i j k l m n o p q r s t u v w x y z)(a b c d e f g h i j k l m n o p q r s t u v w x y z)))

;; I deleted the results, as the resulting table is quite large :) If you run it, it will work. 
#+END_SRC


*** MGX
    #+BEGIN_SRC emacs-lisp :results silent
    (defun map-for-all (pred x domain-y)
  (every (lambda (y) (funcall pred x y)) domain-y))
    #+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
(defun map-for-all-for-all (pred domain-x domain-y)
  (every (lambda (x) (map-for-all pred x domain-y)) domain-x))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(map-for-all-for-all '< [1 2 3] [4 5 6])
#+END_SRC

#+RESULTS:
: t

*** DONE ECI
    CLOSED: [2017-10-11 Wed 20:51]
TODO: Example predicates... 
#+BEGIN_SRC emacs-lisp :results raw
(defun map-for-some (pred x domain-y)
   (some (lambda (y) (funcall pred x y)) domain-y))

(defun map-for-some-for-some (pred domain-x domain-y)
   (some (lambda (x) (map-for-some pred x domain-y)) domain-x))

(defun map-for-some-for-all (pred domain-x domain-y)
   (some (lambda (x) (map-for-all pred x domain-y)) domain-x))

(defun map-for-all-for-some (pred domain-x domain-y)
   (every (lambda (x) (map-for-some pred x domain-y)) domain-x))

;;(map-for-some-for-all '< [1 2 0] [1 2 8])
;;(map-for-some-for-all '> [1 2 0] [5 6 5])
;;(map-for-some-for-all '= [1 2 0] [5 6 7])
#+END_SRC

** DONE GHM
   CLOSED: [2017-10-11 Wed 20:48]
*** DONE MHB
    CLOSED: [2017-10-11 Wed 20:48]
    âˆ€ x âˆ€ y [xRy âˆ§ yRx â†’ x = y]  let p = (xRy \land yRx) and q = (x = y) 
    The implication is that if x is related to y, and y is related to x, then x is equal to y (p->q).
    So if xRy is true, but does not imply q, then yRx must be false for the implication to remain valid. 
   
*** ECT

#+BEGIN_SRC emacs-lisp :results raw
(defun in-the-relation (x y)
  (> x (+ y 1)))
#+END_SRC
    R = [(3 1) (4 1) (4 2)]

*** MKJ
https://math.stackexchange.com/questions/235972/transitive-relations
    * Not relexive (No (3 3))
    * It is symmetric
    * It is not antisymmetric
    * It is transitive

     So this is a symmetric transitive relation
       
*** EFE
https://math.stackexchange.com/questions/235972/transitive-relations
    * It is reflexive
    * It is not symmetric
    * It is antisymmetric
    * It is transitive
It is a reflexive antisymmetric transitive relation

*** MKL
    * It is not reflexive
    * It is symmetric
    * It is not antisymmetric
    * It is not transitive because there is no (1 1)
This is a symetric relation

*** EFS
    1. It is not reflexive
    2. It is not symmetric
    3. It is antisymmetric - vacuously -> There are no symmetric pairs
    4. It is not transitive

This is an antisymmetric relation





*** MLB
#+BEGIN_SRC emacs-lisp
 (defun number-of-binary-relations (n)
    (* n n))

(number-of-binary-relations '10)
#+END_SRC

#+RESULTS:
: 100

** DONE GHN
   CLOSED: [2017-10-14 Sat 12:53]

*** DONE EJE
    CLOSED: [2017-10-12 Thu 11:53]
   
#+BEGIN_SRC emacs-lisp :results raw
(setq students [1 2 3 4 5 6 7 8]
      courses [100 200 300 400]
      by-student '((1 100 200)
                   (2 100)
                   (3 100 200 300)
                   (4 100 200 300 400)
                   (5 100)
                   (6 100)
                   (7 100 200)
                   (8 100 200 300 400))
      by-course '((100 1 2 3 4 5 6 7 8)
                  (200 1 3 4 7 8)
                  (300 3 4 8)
                  (400 4 8)))

(defun student-has-taken-course (student course)
  (not (null (member course (rest (assoc student by-student))))))

(defun course-has-been-taken-by-student (course student)
  (not (null (member student (rest (assoc course by-course))))))


;; similar to the for-all-for-all function, but returns a list of
;; domain-x, saying whether it was true for all across domain-y
(defun all-courses (pred domain-x domain-y)
   (loop for i across domain-x 
     collect (list i (loop for j across domain-y
        always (funcall pred i j)))))



(all-courses 'course-has-been-taken-by-student courses students)
#+END_SRC

#+RESULTS:
((100 t) (200 nil) (300 nil) (400 nil))
((1 nil) (2 nil) (3 nil) (4 t) (5 nil) (6 nil) (7 nil) (8 t))

#+BEGIN_SRC emacs-lisp :results raw
(mapcar 'first by-student)

#+END_SRC

#+RESULTS:
(1 2 3 4 5 6 7 8)
((1 100 200) (2 100) (3 100 200 300) (4 100 200 300 400) (5 100) (6 100) (7 100 200) (8 100 200 300 400))

*** DONE MLU
    CLOSED: [2017-10-14 Sat 12:53]
    
    I tried to get it working in lisp, but I ran out of time, so I just built it in JavaScript :) I might come back later and attempt to 
    translate the JavaScript into lisp. 

#+BEGIN_SRC emacs-lisp :results output
(setq birthday-table [[Bill 1992 Jan 1] [Bob 2001 May 13][Sue 2000 Dec 22] [George 1995 Sep 17] [Maia 1994 May 12]]
      zodiac-table [[Jan 20 Aquarius] [Feb 19 Pisces] [Mar 21 Aries] [Apr 20 Taurus] [May 21 Gemini] [Jun 21 Cancer] [Jul 23 Leo] [Aug 23 Virgo] [Sep 23 Libra] [Oct 23 Scorpio] [Nov 22 Sagittarius] [Dec 22 Capricorn]]
      months-assoc '((Jan . 01) (Feb . 02) (Mar . 03) (Apr . 04) (May . 05) (Jun . 06) (Jul . 07) (Aug . 08) (Sep . 09) (Oct . 10) (Nov . 11) (Dec . 12)))

(defun join-zodiac (s1 s2)
  (loop for i across s1
    append (loop for k across s2 
       until (> (cdr (assoc (elt i 2) months-assoc)) (cdr(assoc (elt k 0) months-assoc)))
          do (princ (list(elt i 0) (cdr(assoc (elt k 0) months-assoc)))))))

(join-zodiac birthday-table zodiac-table)
;;(elt (elt birthday-table 2) 2)
#+END_SRC

#+RESULTS:
: (Bill 1)(Bill 2)(Bill 3)(Bill 4)(Bill 5)(Bill 6)(Bill 7)(Bill 8)(Bill 9)(Bill 10)(Bill 11)(Bill 12)
nil

#+BEGIN_SRC js :results output

const birthday_table = [["Bill", 1992, "Jan", 1], ["Bob", 2001, 'May', 13], ['Sue', 2000, 'Dec', 22], ['George', 1995, 'Sep', 17], ['Maia', 1994, 'May', 12]]
const zodiac_table = [['Jan', 20, 'Aquarius'], ['Feb', 19, 'Pisces'], ['Mar', 21 ,'Aries'], ['Apr', 20, 'Taurus'], ['May', 21, 'Gemini'], ['Jun', 21, 'Cancer'], ['Jul', 23, 'Leo'], ['Aug', 23, 'Virgo'], ['Sep', 23 ,'Libra'] ,['Oct' ,23, 'Scorpio'], ['Nov', 22, 'Sagittarius'],['Dec', 22, 'Capricorn']];
const month_map = {
  'Jan': 0,
  'Feb': 01,
  'Mar': 02,
  'Apr': 03,
  'May': 04,
  'Jun': 05,
  'Jul': 06,
  'Aug': 07,
  'Sep': 08,
  'Oct': 09,
  'Nov': 10,
  'Dec': 11
};

let zodiacs = [];

birthday_table.forEach((birthel)=>{
  const bmonth = month_map[birthel[2]];
  const bday = birthel[3];
  if(bday >= zodiac_table[bmonth][1]) {
    zodiacs.push([birthel, zodiac_table[bmonth][2]]);
  } else {
    //const adjusted_bmonth;
    if(bmonth - 1 < 0) {
      const adjusted_bmonth = 11
      zodiacs.push([birthel, zodiac_table[adjusted_bmonth][2]])
    } else {
      const adjusted_bmonth = bmonth-1;
      zodiacs.push([birthel, zodiac_table[adjusted_bmonth][2]])
    }
  }
});

zodiacs.forEach((el)=>{
  console.log(el); 
});
#+END_SRC

#+RESULTS:
: [ [ 'Bill', 1992, 'Jan', 1 ], 'Capricorn' ]
: [ [ 'Bob', 2001, 'May', 13 ], 'Taurus' ]
: [ [ 'Sue', 2000, 'Dec', 22 ], 'Capricorn' ]
: [ [ 'George', 1995, 'Sep', 17 ], 'Virgo' ]
: [ [ 'Maia', 1994, 'May', 12 ], 'Taurus' ]

*** DONE EJK
    CLOSED: [2017-10-13 Fri 20:55]

#+NAME: example-table
| a   | b   |  c |
| 12  | 23  | 42 |
| YOU | ARE | A  |

#+BEGIN_SRC emacs-lisp :var example-table=example-table
(list example-table)
#+END_SRC

#+RESULTS:
| (a b c) | (12 23 42) | (YOU ARE A) |

** GHQ
*** MMC
    | Set Name | Equiv Class | Lesser Members |     |     |    | \downarrow |    |    |    | Greater Members |
    | A_0       | [0]         | ...            | -21 | -14 | -7 | 0 |  7 | 14 | 21 | ...             |
    | A_1       | [1]         | ...            | -20 | -13 | -6 | 1 |  8 | 15 | 22 | ...             |
    | A_2       | [2]         | ...            | -19 | -12 | -5 | 2 |  9 | 16 | 23 | ...             |
    | A_3       | [3]         | ...            | -18 | -11 | -4 | 3 | 10 | 17 | 24 | ...             |
    | A_4       | [4]         | ...            | -17 | -10 | -3 | 4 | 11 | 18 | 25 | ...             |
    | A_5       | [5]         | ...            | -16 |  -9 | -2 | 5 | 12 | 19 | 26 | ...             |
    | A_6       | [6]         | ...            | -15 |  -8 | -1 | 6 | 13 | 20 | 27 | ...             |
*** EJU
    I would say that the CMM relation would be (mod i 10)
*** MNE
Consider the set of all bitstrings having length at least 3. 
Show that the relation on this set that says two bitstrings are related if they agree in the first three bits is an equivalence relation

An equivalence relation is one which is reflexive, symmetric, and transitive.

The set is reflexive because, if the first three bits agree then there will be instances of a = a

The set is symmetric because, if the first three bits of a agree with b, then the first three bits of b agree with a, so it is symmetric.

The set is transitive because, if the first three bits of a agree with the first three bits of b, and b agrees with c, then a will agree with c.
** GHR
*** EKQ


   1. No, because it is not reflexive, I am not my own sibling.
   2. Yes
   3. No, because it may not always be transitive. I may share a parent with my half-brother, who shares a parent with his half-sister.
      That does not mean that his half-sister and I share the same parent.
   4. No, it is not always transitive. Example: I speak Dutch, which I share in common with my Father. My Father speaks German with his boss. 
      I do not speak German, so I do not have a relation with my Father's boss. It is not transitive
   5. No, again, not always transitive
   6. No, not always symmetric
   7. True
   8. True
   9. True
*** MON
#+BEGIN_SRC emacs-lisp :results output
(defun build-partition-set-table (m &optional n)
  (let* ((count (if (null n) 20 n))
         (bound (* count m)))
    (loop for i from 0 below m
          do (princ "[ ")
          (loop for j from (+ (- bound) i) to (+ bound i) by m
                do (princ j)
                (princ " "))
          (princ "]\n"))))

(build-partition-set-table '5)
#+END_SRC

#+RESULTS:
: [ -100 -95 -90 -85 -80 -75 -70 -65 -60 -55 -50 -45 -40 -35 -30 -25 -20 -15 -10 -5 0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 ]
: [ -99 -94 -89 -84 -79 -74 -69 -64 -59 -54 -49 -44 -39 -34 -29 -24 -19 -14 -9 -4 1 6 11 16 21 26 31 36 41 46 51 56 61 66 71 76 81 86 91 96 101 ]
: [ -98 -93 -88 -83 -78 -73 -68 -63 -58 -53 -48 -43 -38 -33 -28 -23 -18 -13 -8 -3 2 7 12 17 22 27 32 37 42 47 52 57 62 67 72 77 82 87 92 97 102 ]
: [ -97 -92 -87 -82 -77 -72 -67 -62 -57 -52 -47 -42 -37 -32 -27 -22 -17 -12 -7 -2 3 8 13 18 23 28 33 38 43 48 53 58 63 68 73 78 83 88 93 98 103 ]
: [ -96 -91 -86 -81 -76 -71 -66 -61 -56 -51 -46 -41 -36 -31 -26 -21 -16 -11 -6 -1 4 9 14 19 24 29 34 39 44 49 54 59 64 69 74 79 84 89 94 99 104 ]
* Week 5 JKL
  Clock table does not include class time

#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2017-10-21 Sat 15:53]
| Headline           | Time    |      |
|--------------------+---------+------|
| *Total time*       | *10:02* |      |
|--------------------+---------+------|
| Week 5 JKL         | 10:02   |      |
| \_  Reading        |         | 0:05 |
| \_  Week 5 Day One |         | 1:02 |
| \_  Week 5 Day Two |         | 1:02 |
| \_  JKM            |         | 0:21 |
| \_  JKN            |         | 1:37 |
| \_  JKO            |         | 3:08 |
| \_  JKP            |         | 2:47 |
#+END:

** Reading
   :LOGBOOK:
   CLOCK: [2017-10-16 Mon 21:10]--[2017-10-16 Mon 21:15] =>  0:05
   :END:
I ended up just adding the reading under the EPPs except for this first section. That's why there's only 5 min. :)
** DONE Week 5 Day One
   CLOSED: [2017-10-20 Fri 18:27]
    :LOGBOOK:
    CLOCK: [2017-10-17 Tue 10:14]--[2017-10-17 Tue 11:16] =>  1:02
    :END:
*** ICE
**** How Would You?
#+BEGIN_SRC emacs-lisp :results raw
(defun shuffle-ice (set1 set2)
   (vconcat(append [] (loop for i across set1
         for j across set2 
         append (list i j)))))

(shuffle-ice [A B C] [1 2 3])
#+END_SRC

#+RESULTS:
[A 1 B 2 C 3]
[A 1 B 2 C 3]
**** One line solution
#+BEGIN_SRC emacs-lisp
(defun shuffle-one-line (v1 v2)
   (applyl 'vconcat (mapcar* 'vector v1 v2)))
#+END_SRC
** DONE Week 5 Day Two
   CLOSED: [2017-10-20 Fri 18:27]
   Basic Probability Theory
    :LOGBOOK:
    CLOCK: [2017-10-19 Thu 10:15]--[2017-10-19 Thu 11:17] =>  1:02
    :END:
*** Binomial Theorem

    (x + y)^n = Pascals triangle expansion

    \sum k=0, n x^9n-^k y^k
** DONE JKM
   CLOSED: [2017-10-16 Mon 21:40]
*** DONE QAM
    CLOSED: [2017-10-16 Mon 21:19]
    :LOGBOOK:
    CLOCK: [2017-10-16 Mon 21:15]--[2017-10-16 Mon 21:19] =>  0:04
    :END:
    * This will be the product rule and the sum rule. With a set of 5 long-sleeve and 3 short-sleeve, applying the sum rule, we get 8 shirts. 
      We can now combined this sum with the set of pants using the product rule, giving us 1 * 8 = 8 different outfits.
    * So we take the original 8 shirts * 2 pants * 10 ties giving us 160 outfits.
    * The multiplication principle.
*** DONE REX
    CLOSED: [2017-10-16 Mon 21:24]
    :LOGBOOK:
    CLOCK: [2017-10-16 Mon 21:19]--[2017-10-16 Mon 21:24] =>  0:05
    :END:

    The sum should be adjusted to be the length of the set A \cup B 
*** DONE QCV
    CLOSED: [2017-10-16 Mon 21:29]
    :LOGBOOK:
    CLOCK: [2017-10-16 Mon 21:25]--[2017-10-16 Mon 21:29] =>  0:04
    :END:
    If set A is size n, and set B is size m, then there are set m^n functions in A \rarr B.
    So if set A is size 3, and set B is size 5, then there are 5^3 functions, or 125.
*** DONE RFC
    CLOSED: [2017-10-16 Mon 21:39]
    :LOGBOOK:
    CLOCK: [2017-10-16 Mon 21:30]--[2017-10-16 Mon 21:33] =>  0:03
    :END:
    If set A is size n and set B is size m, then the amount of one-to-one functions is
    m!/(m-n)! so 120/2 = 60 one-to-one functions.
*** DONE QCZ
    CLOSED: [2017-10-16 Mon 21:39]
    :LOGBOOK:
    CLOCK: [2017-10-16 Mon 21:34]--[2017-10-16 Mon 21:39] =>  0:05
    :END:
    There are no onto functions from a set X of size 3 and a set Y of size 5. 
    An onto function is surjective, which means that every element in Y is mapped to from X.
    Because size of X \lt Y, it cannot map to every element in Y, therefore, there are no surjective (onto) functions.
** DONE JKN
   CLOSED: [2017-10-17 Tue 22:01]
*** DONE RFF
    CLOSED: [2017-10-17 Tue 20:27]
    :LOGBOOK:
    CLOCK: [2017-10-17 Tue 20:19]--[2017-10-17 Tue 20:27] =>  0:08
    :END:

    How many permuations of the set of vowels are there?
    AEIOUY. There are 6 numbers so n = 6, and all six are being used so r = 6.
    P(6,6) = 6!/(6-6)! = (6*5*4*3*2*1)/1 = 720/1 = 720 possible permutations. 

    6(6-1)(6-2)(6-3)(6-4)(6 -(6 - 1)) = 6(5)(4)(3)(2)(1) 
    this case produces factorial of n, which is basically the same as the above function
    In other cases, where r \ne n, it will still hold true, because the extra bits added by n!
    are removed by (n-r)!
*** DONE QDM
    CLOSED: [2017-10-17 Tue 20:35]
    :LOGBOOK:
    CLOCK: [2017-10-17 Tue 20:27]--[2017-10-17 Tue 20:35] =>  0:08
    :END:
    Assuming the set of word types is [Subject Verb Object], then the number of permutations
    would be P(3,3) = 3!/0! = 6. If you would like to include more specific word types, such as preposition, 
    indirect object, or conjuntion, n and r would increase, increasing the answer. 
*** DONE RGL
    CLOSED: [2017-10-17 Tue 20:43]
    :LOGBOOK:
    CLOCK: [2017-10-17 Tue 20:36]--[2017-10-17 Tue 20:43] =>  0:07
    :END:
    We can demonstrate this with a for loop. I am going to use JavaScript, just 
    because it is a bit easier to look at than Lisp in my opinion. 

#+BEGIN_SRC js :results output
/* Let's define a function that return's factorials using a for loop. 
   It takes one parameter, an integer to calculate the factorial of. */
function factorial(n) {
  // first we define a variable that we will use to 
  // store the product. We must initialize it as 1, otherwise we will always
  // be multiplying by zero, which will always return zero. 
  let prod = 1;
  // Not we define our for loop, notice that i must also begin at 1, otherwise we will only
  // ever get zero for an answer. 
  for(let i = 1; i <= n; i++) {
   prod *= i;
  }
  return prod;
}

// lets see what happens when we run this on a non-zero number. 
console.log(factorial(6));

// now lets try it on zero.
console.log(factorial(0));

/* Because n starts at zero, it does not meet the requirements to intiate the for loop. This means the function
   skips it, and returns the original prod, which is just 1. This is a simple example of why 0! must be 1.*/
#+END_SRC

#+RESULTS:
: 720
: 1
*** DONE QEB 
    CLOSED: [2017-10-17 Tue 20:56]
    :LOGBOOK:
    CLOCK: [2017-10-17 Tue 20:44]--[2017-10-17 Tue 20:56] =>  0:12
    :END:
    If we treat ELM as one object instead of three letters, we can use the permutation formulat to solve this :)
    So instead of a set of 9! arrangements, it is a set of 7! arrangements, which is 5040 arrangments of ABCDELMNO 
    where ELM are always arranged next to each other in that fashion.
*** DONE RGM
    CLOSED: [2017-10-17 Tue 21:00]
    :LOGBOOK:
    CLOCK: [2017-10-17 Tue 20:57]--[2017-10-17 Tue 21:00] =>  0:03
    :END:
      This would just be the cartesian product of the 3 sets, each containing all the letters in the alphabet,
      so 26^3 or 17576 possible TLA's 
*** DONE QFK
    CLOSED: [2017-10-17 Tue 21:08]
    :LOGBOOK:
    CLOCK: [2017-10-17 Tue 21:00]--[2017-10-17 Tue 21:08] =>  0:08
    :END:
    Assuming that letters are allowed to repeat, I believe that it would be the cartesian product of the set of all letters with itself A^2 plus
    the cartesian product of the set of all letters with itself twice, or A^3. So 26^2 + 26^3 = 18252 possible combinations of initals with either 
    two initials (like me :) ) or three intials. 
*** DONE RHB
    CLOSED: [2017-10-17 Tue 21:24]
    :LOGBOOK:
    CLOCK: [2017-10-17 Tue 21:09]--[2017-10-17 Tue 21:24] =>  0:15
    :END:
    Assuming that repeats are allowed... Otherwise you would follow the same formula of summing, but summing the
    permutations instead of the cartesian products. 
    Following the same idea as the previous problem, it will be the sum of several cartesian products. 
    First the product giving us the number of two letter combinations summed with the product of two digit 
    number combinations AND 3 digit number combinations. We would take that sum and add it with the product of 
    all three letter combinations summed with the two different number combinations. This would look something like this:
    
    All the two letter        All the three letter 
    combinations with #'s     combinatinos with #'s
    (26^2 + 10^2 + 10^3)     +    (26^3 + 10^2 + 10^3)
*** DONE QGK
    CLOSED: [2017-10-17 Tue 22:00]
    :LOGBOOK:
    CLOCK: [2017-10-17 Tue 21:24]--[2017-10-17 Tue 22:00] =>  0:36
    :END:

    ccvcv 
    So if we start of with two consonants, than we know that the possible combinations are (20 * 19)
    Multiply that by 6 possible vowels, then another 18 possible consonants and another vowel, giving us
    (20 * 19) * 18 * 5^2  = 171000 
** TODO JKO

*** DONE RVB 
    CLOSED: [2017-10-19 Thu 14:38]
    :LOGBOOK:
    CLOCK: [2017-10-19 Thu 14:30]--[2017-10-19 Thu 14:38] =>  0:08
    CLOCK: [2017-10-18 Wed 23:02]--[2017-10-18 Wed 23:22] =>  0:20
    :END:
#+BEGIN_SRC emacs-lisp :results silent
(defun n-choose-k-cond (n k)
"COmputes C(n, k) by a recursive definition; 
given a pair of nonnegative integers n >= k >= 0.
Also handles invalid input for k. reteurns the value of n choose k"
 (cond ((or (zerop k) (= k n)) 1)
       ((or (< k 0) (> k n)) 0)
       (t  (+ (n-choose-k-cond (- n 1) (- k 1))
       (n-choose-k-cond (- n 1) k)))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :results raw
(n-choose-k-cond '4 '5)
#+END_SRC

#+RESULTS:
0
0
1
4
*** DONE QGT
    CLOSED: [2017-10-19 Thu 11:12]
    :LOGBOOK:
    CLOCK: [2017-10-19 Thu 10:53]--[2017-10-19 Thu 11:12] =>  0:19
    CLOCK: [2017-10-18 Wed 23:22]--[2017-10-18 Wed 23:28] =>  0:06

    :END:
  
    You can see this with Pascal's triangle or the binomial theorem expansion.
    We discussed this in class.
*** DONE RJV 
    CLOSED: [2017-10-19 Thu 15:09]
     :LOGBOOK:
     CLOCK: [2017-10-19 Thu 14:45]--[2017-10-19 Thu 15:08] =>  0:23
     :END:
**** 1. no heads?
     n = 10 (flips) k = 0 (heads)
    
    #+BEGIN_SRC emacs-lisp :results raw
    (n-choose-k-cond '10 '0)
    #+END_SRC

    #+RESULTS:
    1

**** 2. exactly one head
     #+BEGIN_SRC emacs-lisp :results raw 
     (n-choose-k-cond '10 '1)
     #+END_SRC

     #+RESULTS:
     10
**** 3. exactly two heads
    #+BEGIN_SRC emacs-lisp :results raw
    (n-choose-k-cond '10 '2)
    #+END_SRC 

    #+RESULTS:
    45
**** 4. exactly r heads
     10!/(10-r)!r!
**** 5. At least two heads
https://math.stackexchange.com/questions/1353370/number-of-ways-of-choosing-at-least-k-objects-out-of-n

#+BEGIN_SRC emacs-lisp :results silent
(defun n-atleast-k (n k) 
 (loop for i from k to n
        sum (n-choose-k-cond n i)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
(n-atleast-k '10 '2)
#+END_SRC

#+RESULTS:
1013
*** DONE QIQ
    CLOSED: [2017-10-19 Thu 15:19]
    :LOGBOOK:
    CLOCK: [2017-10-19 Thu 15:09]--[2017-10-19 Thu 15:19] =>  0:10
    :END:
#+BEGIN_SRC emacs-lisp :results raw
(n-atleast-k '10 '2)
#+END_SRC

#+RESULTS:
1013
*** DONE RLH
    CLOSED: [2017-10-19 Thu 15:24]
#+BEGIN_SRC emacs-lisp :results raw
(n-choose-k-cond '9 '5)
#+END_SRC

#+RESULTS:
126
*** DONE QKA
    CLOSED: [2017-10-21 Sat 14:37]
    :LOGBOOK:
    CLOCK: [2017-10-21 Sat 14:07]--[2017-10-21 Sat 14:37] =>  0:30
    CLOCK: [2017-10-19 Thu 15:24]--[2017-10-19 Thu 15:47] =>  0:23
    :END:
**** [4 4 3 2]
     First off, there are (52 choose 13) possible hands, so that's 635013559600 possible hands.

     For the first and seconds suits, there are 13 choose 4 combinations, so that's 715 combinations for each, or 1430 possible combinations. 

     The third has 286, and the fourth has 78. 

     So a total of 715 * 715 * 286 * 78 = 11404407300 combinations of suits that match the criteria. We multiply that because of the permutations by 24 = 273705775200

     Because we have a double suit, we divide that number by 2! = 136852887600 possible hands
**** How many different suit distributions are there? 

    We calculated that number above, 635013559600 possible hand distributions.

*** TODO RNC
    :LOGBOOK:
    CLOCK: [2017-10-21 Sat 14:46]--[2017-10-21 Sat 15:35] =>  0:49
    :END:

    I'm not sure. I know we are looking for when the number will exceed 2**29
    But I'm not sure how to calculate it. Will work on it more next week. 

** JKP

*** DONE QKT
    CLOSED: [2017-10-20 Fri 16:25]
    :LOGBOOK:
    CLOCK: [2017-10-20 Fri 16:23]--[2017-10-20 Fri 16:25] =>  0:02
    :END:
    4/36 = 1/9

*** DONE RNM
    CLOSED: [2017-10-20 Fri 16:41]
    :LOGBOOK:
    CLOCK: [2017-10-20 Fri 16:25]--[2017-10-20 Fri 16:41] =>  0:16
    :END:
    We have 8 possible outcomes:

HH H, HT H, TT H, HH T, HT T, TH H, TH T, TT T. 
In 4 of those outcomes Ed has more heads, so the probability is 1/2, Which ironically is the same as with one coin. 

 

#+BEGIN_SRC emacs-lisp 
(get-hint 'RNM)
#+END_SRC

#+RESULTS:
#+begin_example
  Rather than roll dice, Ruth and Ed usually flip a coin to decide who's going
  to do the chores. One day Ed complains --- he thinks he loses too often. So
  Ruth says, \ldquo{}OK, this time you flip two coins, and I flip one. If you get more
  heads than I do, I\rsquo{}ll clean the toilets.\rdquo Ed likes Ruth\rsquo{}s display of
  generosity and says, \ldquo{}You\rsquo{}re on!\rdquo

  What are his chances?
:HINT:
  - Hint :: This was adapted from a problem posed by Marilyn Vos Savant in her
            \ldquo{}Ask Marilyn\rdquo Parade Magazine column.
:END:
,#+BEGIN_SRC emacs-lisp :exports results :results html
  (insert-helpbox)
,#+END_SRC
#+end_example

*** TODO QOS
    :LOGBOOK:
    CLOCK: [2017-10-21 Sat 13:48]--[2017-10-21 Sat 14:05] =>  0:17
    CLOCK: [2017-10-20 Fri 18:32]--[2017-10-20 Fri 18:32] =>  0:00
    CLOCK: [2017-10-20 Fri 16:43]--[2017-10-20 Fri 17:04] =>  0:21
    :END:
    With 2n coins, the the probability space will be (2n)^2 -> [(2(1))^2 = 4 outcomes for 2 coins, (2(2))^2 = 16 for 4 coins where n is the number of coins /2, hence, 2n coins]
    
    I'm not sure what this is asking, I will discuss it with Bro. Neff next week. 

*** DONE ROP
    CLOSED: [2017-10-20 Fri 18:52]
    :LOGBOOK:
    CLOCK: [2017-10-20 Fri 18:32]--[2017-10-20 Fri 18:52] =>  0:20
    :END:

**** 1. The first 13 letters will be in alphabetical order
     There are 26! combinations of the uppercase letters. 
     There are 13! ways the first 13 numbers can be arranged 
     so (26!/13!)/26! is equal to 1/13!

**** 2. The first and last letters will be B and Y.  
     There are 24! ways to arrange the other letters (subtracting B and Y) 
     so it will be 24!/26! = 1/650

**** 3. The letter I will come before both J and K
     1/3

**** 4. The letters O and P will be next to each other
     2(25!/26!) = 1/13

**** 5. The letters U and V will be at least 23 spaces apart.
     6(24!)/(26!) = 3/325 
*** DONE QRQ
    CLOSED: [2017-10-20 Fri 16:43]

We worked on this one in class. 

   #+BEGIN_SRC emacs-lisp :results silent
(defun size-prob (seq)
   (float (length seq)))

;;(require 'cl)

(defun probability (event space)
  "A function that takes an event and a space
and returns a number between 0 and 1."
  (let ((result (/ (size-prob event) (size-prob space))))
    (if (subsetp (append event nil) (append space nil))
    result
    (error "Bad Parameters"))))
   #+END_SRC 

#+BEGIN_SRC emacs-lisp :results raw
(probability [1 2 3 4] [1 2 3 4 5 6])
#+END_SRC

#+RESULTS:
0.6666666666666666
0.5
*** DONE ROX
    CLOSED: [2017-10-20 Fri 18:19]
    :LOGBOOK:
    CLOCK: [2017-10-21 Sat 8:46]--[2017-10-21 Sat 10:17] => 1:31
    :END:
This code is based of the brief example we got to see in class. I don't know if its exactly the same, but I had to play with it quite a bit to 
get it to work. 
    #+BEGIN_SRC emacs-lisp :results silent
    (defun 3-digit-date-prob () 
       (let* (
              ;; Here we define our invalid date ranges. These are ranges that we know are invalid
             (invalid-dates '(100 (111 . 119) (121 . 129) (132 . 209) (230 . 309) (332 . 409) (431 . 509) (532 . 609) (631 . 709) (732 . 809) (832 . 909) (931 . 909)))
             ;; Here we define our valid date ranges. Again, these are ranges that we know are valid
             (valid-dates '((101 . 110) 120 130 131 (210 . 229) (310 . 331) (410 . 430) (510 . 531) (610 . 630) (710 . 731) (810 . 831) (910 . 930)))

             ;; Here we are making a list of all the invalid dates from the ranges we provided above
             (get-invalid 
             (loop for i in invalid-dates 
                   append (if (consp i) ;; if it is an object, then it must be a sublist, so loop through it. 
                          (loop for k from (car i) to (cdr i) ;; use the car as the initial, and use the cdr to get the full range to loop through
                                collect k) (list i)))) ;; otherwise just append the number in the list
             (get-valid  ;; We go through the same process for the valid date ranges
             (loop for i in valid-dates
                   append (if (consp i)
                   (loop for k from (car i) to (cdr i)
                         collect k) (list i))))
                         ;; now we can calculate the probability based on the lengths of the lists we just created
             (prob (/ (length get-valid) (float (length (union get-invalid get-valid))))))

             prob))
    #+END_SRC

#+BEGIN_SRC emacs-lisp
(3-digit-date-prob)
#+END_SRC

#+RESULTS:
: 0.2214199759326113
* Week 6 MNO
#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2017-10-28 Sat 14:05]
| Headline           | Time    |      |
|--------------------+---------+------|
| *Total time*       | *10:06* |      |
|--------------------+---------+------|
| Week 6 MNO         | 10:06   |      |
| \_  Week 6 Day One |         | 1:01 |
| \_  Week 6 Day Two |         | 1:03 |
| \_  MNQ            |         | 2:37 |
| \_  MNR            |         | 0:30 |
| \_  MNS            |         | 1:37 |
| \_  MNT            |         | 0:37 |
| \_  MNU            |         | 1:49 |
| \_  MNV            |         | 0:18 |
| \_  MNW            |         | 0:34 |
#+END:

** Week 6 Day One
   :LOGBOOK:
   CLOCK: [2017-10-24 Tue 10:14]--[2017-10-24 Tue 11:15] =>  1:01
   :END:
*** ICE
**** Impressions
     
     Using complex numbers to change a geometry problem to an algebra problem
     25 = 4^2 + 3^2 = (3 + 4i)(3 - 4i)

     Square root of prime numbers 1 above a factor of 4 always hit 8 lattice points. Can be split into Gaussian primes. 

     Square root of prime numbers 3 above a factor of 4 always hit 0 lattice points. Cannot be split into Gaussian primes

     A prime number is always one more than a multiple of six, or one less than a multiple of six (except 2).

     Factor n into ordinary integers then into Gaussian primes
     Organize into two columns of Conjucate pairs and multiply each column with itself
     Then take the output of each column and multiply them together.


     multiplicative function - a function that given f(b) *  f(a) = f(ab)

     So how does this apply to what we are doing? Number Theory is all about connecting patterns. Developing
     the mindset to see these patterns is essential to completing these problems. 
**** \pi(n) \rho(n)
     \pi(\rho(n)) = n
     \rho(\pi(n)) = n
** Week 6 Day Two
   :LOGBOOK:
   CLOCK: [2017-10-26 Thu 10:13]--[2017-10-26 Th 11:16] =>  1:02
   :END:   
*** 5 EPPS to beware of 
**** FJY in MNT
**** IYJ in MNT
**** FOY in MNU
**** FQL in MNV
**** FVF in MNX

** TODO MNQ
   :LOGBOOK:
   CLOCK: [2017-10-23 Mon 16:08]--[2017-10-23 Mon 16:22] =>  0:14
   :END:
*** DONE FAB
    CLOSED: [2017-10-24 Tue 14:25]
    :LOGBOOK:
    CLOCK: [2017-10-24 Tue 14:20]--[2017-10-24 Tue 14:25] =>  0:05
    :END:
    The reduntant word is evenly. By the definition of the word divides, a/b is an integer, so saying
    a divides b evenly is redundant.
*** DONE ISM
    CLOSED: [2017-10-25 Wed 23:52]
    :LOGBOOK:
    CLOCK: [2017-10-25 Wed 23:28]--[2017-10-25 Wed 23:51] =>  0:23
    CLOCK: [2017-10-23 Mon 22:47]--[2017-10-23 Mon 23:04] =>  0:17
    CLOCK: [2017-10-23 Mon 16:23]--[2017-10-23 Mon 17:24] =>  1:01
    :END:


#+BEGIN_SRC js :results output
function sumDigits(number) {
    const remainder = number % 10;
    let sum = remainder;
    if(number >= 10) {
        const rest = Math.floor(number / 10);
        sum += sumDigits(rest); 
    }
    return sum;
}

function isDivisibleBy2(num) {
  num = num % 10;
  switch (num) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 8:
     return true;
    default:
     return false;
  }
}

function isDivisibleBy3 (num) {
  const sum = sumDigits(num);
  if (num % 3)
    return false;
  return true;
}

function isDivisibleBy4(num) {
  num = num % 100;
  if(num % 4) 
    return false
  return true;
}


function isDivisibleBy5(num) {
  num = num % 10;
  if(num === 5 || num === 0)
     return true;
  return false;
}


function isDivisibleBy6(num) {
  if(isDivisibleBy2(num) && isDivisibleBy3(num)) 
    return true;
  return false;
}

function isDivisibleBy7(num) {
   if(num.toString().length === 1) {
     return num === 0 || num === 7;
   }
   const stem = (num % 10) * 2;
   const rest = parseInt(num.toString().substr(0, num.toString().length - 1));
   return isDivisibleBy7(Math.abs(rest - stem));
}

function isDivisibleBy8(num) {
  if((num % 1000) % 8) 
    return false;
  return true;
}


function isDivisibleBy9(num) {
  if(sumDigits(num) === 9) 
     return true;
  else if((sumDigits(num) >= 0))
     return false;
 return isDivisibleBy9(sumDigits(num));
}

function isDivisibleBy10(num) {
  return isDivisibleBy2(num) && isDivisibleBy5(num);
}

function isDivisibleBy11(num) {
    num = num + '';
    let oddInd = [];
    let evenInd = [];
    for(let i = 0; i < num.length; i++ ) {
        if(i % 2) {
            evenInd.push(num[i])
        } else {
            oddInd.push(num[i]);
        }
    }
    let sums = []
    oddInd.forEach((t, i) => {
        sums[i] = t - evenInd[i];
    })
    
    return sums.reduce((sum, val) => {
        return sum + val;
    }) ? true : false;
}

console.log(isDivisibleBy3(13097034951));

#+END_SRC

#+RESULTS:
: true

*** DONE FBH
    CLOSED: [2017-10-25 Wed 23:55]
    :LOGBOOK:
    CLOCK: [2017-10-25 Wed 23:53]--[2017-10-25 Wed 23:55] =>  0:02
    CLOCK: [2017-10-23 Mon 22:06]--[2017-10-23 Mon 22:25] =>  0:19
    :END:
    
    #+BEGIN_SRC emacs-lisp :results silent
    (defun sum-of-digits(number) 
     (if (= number 0) 0 
        (+ (mod number 10) 
           (sum-of-digits (/ (- number (mod x 10)) 10)))))
    #+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
(sum-of-digits '123)
#+END_SRC

*** DONE ITT
    CLOSED: [2017-10-23 Mon 22:29]
    :LOGBOOK:
    CLOCK: [2017-10-23 Mon 22:25]--[2017-10-23 Mon 22:29] =>  0:04
    :END:
    1. Find the prime factorization of the integer
    2. Write out all the exponents
    3. Take each exponent and add one to it
    4. Find the product of the numbers in step 3.
*** TODO FDK
    :LOGBOOK:
    CLOCK: [2017-10-23 Mon 22:29]--[2017-10-23 Mon 22:41] =>  0:12
    :END:
** DONE MNR
   CLOSED: [2017-10-26 Thu 10:18]
   :LOGBOOK:
   CLOCK: [2017-10-24 Tue 14:27]--[2017-10-24 Tue 14:40] =>  0:13
   :END:
*** DONE IVO
    CLOSED: [2017-10-26 Thu 10:17]
    :LOGBOOK:
    CLOCK: [2017-10-26 Thu 00:01]--[2017-10-26 Thu 00:18] =>  0:17
    :END:
    composite(n) \harr \not [\forall x \forall y [(x > 1 âˆ§ y > 1) â†’ xy â‰  n]]
    composite(n) \harr \exists x \not [\forall y [(x > 1 \land y > 1)] \rarr xy \ne n]]
    composite(n) \harr \exists x \exists y \not [(x > 1 \land y > 1)] \rarr xy \ne n]
    composite(n) \harr \exists x \exists y \not (p \rarr q) where p = (x >1 \land y > 1) and q = (xy \ne n)
    composite(n) \harr \exists x \exist y [(x > 1 \land y > 1)] \land \not (xy \ne n)]
    composite(n) \harr \exists x \exists y [(x > 1 \land y > 1) \land (xy = n)]
    
** DONE MNS
   CLOSED: [2017-10-24 Tue 23:22]
   :LOGBOOK:
   CLOCK: [2017-10-24 Tue 15:09]--[2017-10-24 Tue 15:18] =>  0:09
   :END:
*** DONE FDZ
    CLOSED: [2017-10-24 Tue 22:49]
    :LOGBOOK:
    CLOCK: [2017-10-24 Tue 19:32]--[2017-10-24 Tue 19:52] =>  0:20
    :END:

#+BEGIN_SRC emacs-lisp :results raw
(defun prime-power-list-to-number (prime-power-list)
    (reduce #'* (loop with number = 1
          with primes = [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71]
          for prime across primes
          for power in prime-power-list
          collect (* number (expt prime power)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp 
(prime-power-list-to-number '(6 5 4 3 2 1))
#+END_SRC

#+RESULTS:
: 5244319080000
*** DONE IWC
    CLOSED: [2017-10-24 Tue 23:21]
    :LOGBOOK:
    CLOCK: [2017-10-24 Tue 22:13]--[2017-10-24 Tue 23:21] =>  1:08
    :END:
#+BEGIN_SRC emacs-lisp :results silent
;;(defun prime-powers-to-number (collection-of-primes)
    ;;   (let* ((collection-of-primes-list (append collection-of-primes '()))
           ;;   (primes [2 3 5 7 11 13 17 19 23 29 31 41 43 47 53 59 61 57 71])
         ;;     (number 1))
       ;;(apply #'* )
       ;;(mapcar* 
      ;; primes collection-of-primes-list)
    ;;   ))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
(defun prime-powers-to-number (collection-of-prime-powers)
       (let* ((primes [2 3 5 7 11 13 17 19 23 29 31 41 43 47 53 59 61 57 71]))
        (apply #'* (mapcar* #'expt
                  primes collection-of-prime-powers))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
(prime-powers-to-number '(0 1 2 3))
#+END_SRC

#+RESULTS:
25725
376639725
5244319080000
5244319080000
*** DONE FJH
    CLOSED: [2017-10-24 Tue 23:24]
#+BEGIN_SRC emacs-lisp :results raw
(prime-powers-to-number [2 0 0 0 0 1])
#+END_SRC

#+RESULTS:
52
** TODO MNT 
*** DONE IWK
    CLOSED: [2017-10-24 Tue 23:44]
    :LOGBOOK:
    CLOCK: [2017-10-24 Tue 23:25]--[2017-10-24 Tue 23:43] =>  0:18
    :END:
****  Values where 4k + 11 is non-prime
     k = 1 -> 4 + 11 = 15; 
     k = 4 -> 16 + 11 = 27;
     k = 6 -> 24 + 11 = 35;
     k = 7 -> 28 + 11 = 39;
     k = 10 -> f(k) = 51;
     k = 11 -> f(k) = 55
     k = 13 -> f(k) = 63
     k = 16 -> f(k) = 75
     k = 19 -> f(k) = 87
     k = 20 -> f(k) = 91
**** Values where 4k + 11 is prime
     k = 2 -> 8 + 11 = 19;
     k = 3 -> 12 + 11 = 23;
     k = 5 -> 20 + 11 = 31; 
     k = 8 -> 32 + 11 = 43
     k = 9 -> 36 + 11 = 47
     k = 12 -> f(k) = 59
     k = 14 -> f(k) = 67
     k = 15 -> f(k) = 71
     k = 17 -> f(k) = 79
     k = 18 -> f(k) = 83!
*** TODO FJY
*** DONE IXT
    CLOSED: [2017-10-26 Thu 20:10]
    âˆ€qâˆƒpâˆ€xâˆ€y[p>qâˆ§((x>1âˆ§y>1)â†’xyâ‰ p)]

for all q there exists a p for all x and all y that if p > q and x and y > 1 then xy \ne p

if p implies q, then there is no largest p

prime(n) = (x > 1 \land y > 1) \rarr xy \ne p

âˆ€qâˆƒpâˆ€xâˆ€y([p>qâˆ§prime(p) \land prime(q + 2)])  
*** DONE FMD
    CLOSED: [2017-10-26 Thu 20:08]
    :LOGBOOK:
    CLOCK: [2017-10-26 Thu 19:49]--[2017-10-26 Thu 20:08] =>  0:19
    :END:

I know that this is noe the most effecient solution, but I was pressed for time, and it works :)
    #+BEGIN_SRC js :results output
const testPrime = (n) => {
  if (n===1){
    return false;
  }
  else if(n === 2) {
    return true;
  } else {
    for(let x = 2; x < n; x++) {
      if(n % x === 0) {
        return false;
      }
    }
    return true;  
  }
}

const squares = () => {
  let coll = [];
  for(let i = 1; i <= 100; i++ ) {
    const range = {
      min: i * i,
      max: (i + 1) * (i + 1)
    }
    coll.push(range);
  }
  return coll
}

const primes = (ranges) => {
  const primeList = [];
  ranges.forEach((item) => {
    for(let i = item.min; i < item.max; i++) {
      if(testPrime(i)) {
        item.lowestPrime = i;
        primeList.push(item);
        return;
      }
    }
  });
  return primeList;
}

console.log(primes(squares()));
    #+END_SRC
*** TODO IYJ
** TODO MNU
*** DONE FOJ 
    CLOSED: [2017-10-26 Thu 21:07]
    :LOGBOOK:
    CLOCK: [2017-10-26 Thu 20:35]--[2017-10-26 Thu 21:07] =>  0:32
    :END:   
**** CCS of length 2
     (8 9)
**** CCS of length 3
     (8 9 10)
**** CCS of length 4
     (24 25 26 27) 
**** CCS of length 10
      (114, 115, 116, 117, 118, 119, 120, 121, 122, 123) 
*** DONE IZL
    CLOSED: [2017-10-26 Thu 21:54]
    :LOGBOOK:
    CLOCK: [2017-10-26 Thu 21:08]--[2017-10-26 Thu 21:54] =>  0:46
    :END:
#+BEGIN_SRC emacs-lisp :results silent
(defun factorial (n)
  (if (zerop n)
      1
    (* n (factorial (- n 1)))))

(defun consecutive-composite-sequence-of-length (r)
  (let ((r+1-factorial (factorial (1+ r))))
    (loop for n from 1 to r
          collect (+ r+1-factorial n 1))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :results raw
(consecutive-composite-sequence-of-length 4)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
(defun all-composite (r) 
   (every #'identity (mapcar (lambda (x) 
             (or (and (= (mod x 3) 0) (/= x 3))
                 (and (= (mod x 2) 0) (/= x 2))
                 (and (= (mod x 5) 0 (/= x 5)))
                  ))
             r))
)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
(all-composite [4 7 9])
#+END_SRC

#+RESULTS:
nil
(t t t)

I think if you are able to know the prime distribution in the range that the composite sequence covers, you could 
use that knowledge to manage a guess at whether or not a certain range contains a prime number. It may not be 100 percent
accurate, but if you have a large sequence, you may not have to brute force the entire list before making an educated guess 
on where a prime may be hiding. 
*** TODO FOY
*** DONE VAO
    CLOSED: [2017-10-28 Sat 12:50]
    :LOGBOOK:
    CLOCK: [2017-10-28 Sat 12:38]--[2017-10-28 Sat 12:50] =>  0:12
    CLOCK: [2017-10-26 Thu 22:16]--[2017-10-26 Thu 22:35] =>  0:19
    :END:
#+BEGIN_SRC emacs-lisp :results silent
(defun maybe-find-factorization (number limit)
  (mapc (lambda (n)
          (let* ((a (floor (sqrt number)))
                 (s (+ a n))
                 (x (sqrt (- (* s s) number))))
            (when (= x (floor x))
              (princ (format "n = %d, a = %d, s = %d, x = %d,
 factor1 = s - x = %d,
 factor2 = s + x = %d\n"
                             n a s x (- s x) (+ s x))))))
        (number-sequence 1 limit)))
#+END_SRC
#+BEGIN_SRC emacs-lisp :results output
(maybe-find-factorization 125 10)
#+END_SRC

#+RESULTS:
: n = 4, a = 11, s = 15, x = 10,
:  factor1 = s - x = 5,
:  factor2 = s + x = 25

It assumes that x and s are close, otherwise it will take very long to factor.


#+RESULTS:
*** TODO FQI
** TODO MNV
*** VAR
    :LOGBOOK:
    CLOCK: [2017-10-28 Sat 12:51]--[2017-10-28 Sat 13:09] =>  0:18
    :END:
    
    720720, yes it is divisible it has 10 prime factors.
*** TODO FQL
** MNW
   :LOGBOOK:
   CLOCK: [2017-10-28 Sat 13:10]--[2017-10-28 Sat 13:17] =>  0:07
   :END:
*** VAY
    :LOGBOOK:
    CLOCK: [2017-10-28 Sat 13:20]--[2017-10-28 Sat 13:34] =>  0:14
    :END:
**** 1. 57/43
     57/43 = 1 r 14
     43 / 14 = 3 r 1
     14 / 1 = 14 r = 0
     b = 1 gcd = 1
**** 2. 501/39
     501/39 = 12 r 33
     39 / 33 = 1 r 6
     33 / 6 = 5 r 3
     6 / 3 = 2 r 0
     b = 3 gcd = 3
**** 3. 765/110
     765/110 = 6 r 105
     110 / 105 = 1 r 5
     105 / 5 = 21 r = 0
     gcd = 5
**** DONE 4. 899 / 493
     CLOSED: [2017-10-28 Sat 13:40]
     899/493 = 1 r 406
     493/406 = 1 r 87
     406 / 87 = 4 r 58
     87 / 58 = 1 r 29
     58 /29 = 2 r 0
     gcd = 29
*** DONE FQW
    CLOSED: [2017-10-28 Sat 13:40]
    :LOGBOOK:
    CLOCK: [2017-10-28 Sat 13:34]--[2017-10-28 Sat 13:40] =>  0:06
    :END:

I predict that this will return true.

#+BEGIN_SRC emacs-lisp :results raw
(and (= (gcd 56 8) 8)
     (= (gcd 65 15) 5)
     (= (lcm 5 7) 35)
     (= (lcm 4 6) 12))
#+END_SRC

#+RESULTS:
t

Some of these it was easy to tell that it would be true. For instance, the first one, we know that the gcd can't be more than 8, 
and we also know that both are divisible by 8, so its pretty easy to assert that it is true. With lcm 5 7, we know that all multiples
of 5 must end in 0 or 5, so we can mentally check the multiples of 7 and find the first that ends with a 0 or a 5, 35. 
Some of the others take a bit more work to predict. 
*** VCR
    :LOGBOOK:
    CLOCK: [2017-10-28 Sat 13:58]--[2017-10-28 Sat 14:05] =>  0:07
    :END:
#+BEGIN_SRC emacs-lisp :results raw
(and (= (* (gcd 35 72) (lcm 35 72)) (* 35 72))
(= (* (gcd 10 2) (lcm 10 2)) (* 10 2))
(= (* (gcd 13 64) (lcm 13 64)) (* 13 64)))
#+END_SRC

#+RESULTS:
t
t

I believe it will. After doing some research, I think I have found some evidence to backup that claim. 
You can find a series of proofs here that show that gcd(a,b) * lcm(a,b) = a * b
https://math.stackexchange.com/questions/470807/prove-that-gcdm-n-times-mboxlcmm-n-m-times-n
* Week 7 MNO & PQR
#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2017-11-04 Sat 14:09]
| Headline         | Time   |      |
|------------------+--------+------|
| *Total time*     | *9:15* |      |
|------------------+--------+------|
| Week 7 MNO & PQR | 9:15   |      |
| \_  Week 7 Day 1 |        | 1:00 |
| \_  Week 7 Day 2 |        | 1:02 |
| \_  MNU          |        | 0:07 |
| \_  MNW          |        | 0:54 |
| \_  MNX          |        | 2:47 |
| \_  MNY          |        | 0:38 |
| \_  MNZ          |        | 0:41 |
| \_  MN@          |        | 0:19 |
| \_  PQS          |        | 0:32 |
| \_  PQU          |        | 0:17 |
| \_  PQV          |        | 0:58 |
#+END:
 
** Week 7 Day 1
   :LOGBOOK:
   CLOCK: [2017-10-31 Tue 10:15]--[2017-10-31 Tue 11:15] =>  1:00 
   :END:
*** ICE
    see next top tier heading
*** Why?
    Why is X the unknown? Because you can't say 'SH' in Spanish. 
*** What is Understanding?
   * Knowing why something is the way it is
   * Being able to explain something to someone, and teach them to equivelant fluency. 
*** Label Learning
    AVOID IT!
** Week 7 Day 2
   :LOGBOOK:
   CLOCK: [2017-11-02 Thu 10:14]--[2017-11-02 Thu 11:16] =>  1:02
   :END:
*** POWMOD
#+BEGIN_SRC emacs-lisp :results raw
   (require 'calc)
   (calc-eval "893^123%809")
#+END_SRC

#+RESULTS:
69


#+BEGIN_SRC emacs-lisp :results silent

(= (mod (* 235 827) 13) (mod (* (mod 235 13) (mod 827 13)) 13))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
(defun pow-mod (base power modulus)
   (let* ((result 1)
      (base (mod base modulus)))
      (while (> power 0)
        (when (oddp power)
        (setq result (mod (* result base) modulus)))
        (setq base (mod (* base base) modulus)
              power (/ power 2))
      ) result ))

#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
(pow-mod 409 890531 1025)
#+END_SRC

#+RESULTS:
409
14
123

** DONE MNU
   CLOSED: [2017-10-30 Mon 22:33]
*** DONE FQL
    CLOSED: [2017-10-30 Mon 22:33]
    :LOGBOOK:
    CLOCK: [2017-10-30 Mon 22:25]--[2017-10-30 Mon 22:32] =>  0:07
    :END:
#+BEGIN_SRC emacs-lisp :results silent
(defun reconstitute-primes (rle-list)
  (loop for b in rle-list
        for n from 2
        unless (or (zerop b) (and (> b 1) (incf n (- b 1))))
        collect n))

(defun prime-list-from-rle-list (rle-list limit)
  (mapcar 'first
          (remove-if
           (lambda (x)
             (zerop (second x)))
           (mapcar* 'list
                    (number-sequence 2 limit)
                    (apply 'append
                           (mapcar (lambda (x)
                                     (if (> x 1)
                                         (make-list x 0)
                                       (list x)))
                                   rle-list))))))
#+END_SRC

Set the limit to 97 or more
#+BEGIN_SRC emacs-lisp :results raw
;;(prime-list-from-rle-list '(1 1 0 1 0 1 3 1 0 1 3 1 0 1 3 1 5 1 0 1 5 1 3 1 0
  ;;                  1 3 1 5 1 5 1 0 1 5 1 3 1 0 1 5 1 3 1 5 1 7 1 3) 50)

(setq limit 97
      p100rle (list 1 1 0 1 0 1 3 1 0 1 3 1 0 1 3 1 5 1 0 1 5 1 3 1 0
                    1 3 1 5 1 5 1 0 1 5 1 3 1 0 1 5 1 3 1 5 1 7 1 3)
      got-it-right (equal (reconstitute-primes p100rle)
                          (prime-list-from-rle-list p100rle limit)))
#+END_SRC

#+RESULTS:
t
nil
t
t

** DONE MNW
   CLOSED: [2017-11-01 Wed 20:45]
*** DONE FRM 
    CLOSED: [2017-10-30 Mon 22:25]
    :LOGBOOK:
    CLOCK: [2017-10-30 Mon 22:02]--[2017-10-30 Mon 22:25] =>  0:23
    :END:

    272160

    #+BEGIN_SRC emacs-lisp :results silent
    (defun gcd-lcm-ab (a-in-csf b-in-csf)
  (let* ((a-csf-powers (prime-powers-to-number a-in-csf))
         (b-csf-powers (prime-powers-to-number b-in-csf))
         (gcd-of-a-and-b-in-csf (gcd a-csf-powers b-csf-powers))
         (lcm-of-a-and-b-in-csf (lcm a-csf-powers b-csf-powers))
         (product-of-a-and-b-in-csf (* b-csf-powers a-csf-powers)))
    (list gcd-of-a-and-b-in-csf
          lcm-of-a-and-b-in-csf
          product-of-a-and-b-in-csf)))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp :results raw
    (gcd-lcm-ab '(3 2 1 0) '(2 3 0 1))
    #+END_SRC

    #+RESULTS:
    (36 7560 272160)
*** DONE VEM
    CLOSED: [2017-10-31 Tue 21:35]
    :LOGBOOK:
    CLOCK: [2017-10-31 Tue 21:17]--[2017-10-31 Tue 21:35] =>  0:18
    CLOCK: [2017-10-30 Mon 22:33]--[2017-10-30 Mon 22:46] =>  0:13
    :END:

    #+BEGIN_SRC emacs-lisp :results silent
 (defun gcdi (a b)
  (let ((x a) (y b) r)
    (while (not (zerop y))
      (setq r (mod x y) x y y r))
    x))
    #+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
(gcdi 899 493)
#+END_SRC

#+RESULTS:

As far as I can tell, they seem to execute and find the gcd in the same time. I do think that the
built in gcd function may be a bit more effecient. The built in gcd function is recursive while this 
is iterative. 

#+BEGIN_SRC emacs-lisp :results silent
(defun gcdr (a b)
   (if (zerop b)
       a
     (gcdr b (mod a b))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :results raw
(gcdr 899 493)
#+END_SRC

#+RESULTS:
0.000000

If I understand correctly, this is almost if not exactly the same way that the cl-gcd function is implemented...
** MNX
   :LOGBOOK:
   CLOCK: [2017-10-31 Tue 21:35]--[2017-10-31 Tue 21:43] =>  0:08
   :END:
*** DONE FUA
    CLOSED: [2017-10-31 Tue 21:52]
    :LOGBOOK:
    CLOCK: [2017-10-31 Tue 21:43]--[2017-10-31 Tue 21:52] =>  0:09
    :END:
#+BEGIN_SRC emacs-lisp :results silent
(defalias 'div '/)

(defun alternate-base-representation (n b)
  (let ((d (div n b))
        (m (mod n b)))
    (if (zerop d)
        (list m)
      (append (alternate-base-representation d b) (list m)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
(alternate-base-representation 300 8)
(alternate-base-representation 300 78)
(alternate-base-representation 124127923 12)
#+END_SRC

#+RESULTS:
(3 5 6 10 1 3 5 7)
(3 66)
(4 5 4)

As we saw in the reading right before this EPP, some base systems
allow us to represent numbers using symbols or patterns that are 
easily convertible between formats. Another great example of this
is hexidecimal and binary, they allow for easy representation and
conversion of data, especially binary data in hex. I wouldn't say that
there are bases that are completely useless, but it really depends on 
the situation and the data you are trying to represent. 
*** DONE VFJ
    CLOSED: [2017-11-01 Wed 20:44]
    :LOGBOOK:
    CLOCK: [2017-11-01 Wed 19:49]--[2017-11-01 Wed 20:44] =>  0:55
    CLOCK: [2017-10-31 Tue 21:53]--[2017-10-31 Tue 23:12] =>  1:18
    :END:
    
    | B      | r      | y      | a     | n      | M      | u      | l      | l      | e     | r      |
    | 2      | 18     | 25     | 1     | 14     | 13     | 21     | 12     | 12     | 5     | 18     |
    | 2*27^10 | 18*27^9 | 25*27^8 | 1*27^7 | 14*27^6 | 13*27^5 | 21*27^4 | 12*27^3 | 12*27^2 | 5*27^1 | 18*27^0 |

   556119839512287 <- That's a big number!

    #+BEGIN_SRC js :results output
const base27 = {
    '_': 0,
    A: 1,
    B: 2,
    C: 3,
    D: 4,
    E: 5,
    F: 6,
    G: 7,
    H: 8,
    I: 9,
    J: 10,
    K: 11,
    L: 12,
    M: 13,
    N: 14,
    O: 15,
    P: 16,
    Q: 17,
    R: 18,
    S: 19,
    T: 20,
    U: 21,
    V: 22,
    W: 23,
    X: 24,
    Y: 25,
    Z: 26
};


function fromBase27(num) {
    num = num.toUpperCase().replace(' ', '_');
    let coeff = getFromCoeffs(num, []);
    return coeff.reduce((sum, value, index) => {
        return sum + (value * Math.pow(27, (coeff.length - 1) - index));
    }, 0);
}

function getFromCoeffs(num, arr) {
    if (num) {
        const sub = num.slice(0, 1)
        num = num.slice(1);
        arr.push(base27[sub]);
        return getFromCoeffs(num, arr);
    } else {
        return arr;
    }
}

function getToCoeffs(num, arr) {
    
    if (parseInt(num / 27) === 0) {
        arr.push(getKeyByValue(base27, num % 27));
        return arr;
    } else {
        const step1 = parseInt(num % 27);
        const step2 = parseInt((num - step1) / 27);
        arr.push(getKeyByValue(base27, step1));
        return getToCoeffs(step2, arr);
    }
}

function getKeyByValue(object, value) {
    return Object.keys(object).find(key => object[key] === value);
}

function toBase27(num) {
    const coeff = getToCoeffs(num, []);
    return coeff.reduceRight((str, x)=> {
        return str + x;
    })
}

console.log(fromBase27("BryanMuller"));
console.log(toBase27(556119839512287));
console.log(toBase27(fromBase27("Rick Neff")));

    #+END_SRC

    #+RESULTS:
    : 556119839512287
    : BRYANMULLER
    : RICK_NEFF
*** TODO FVF
    :LOGBOOK:
    CLOCK: [2017-11-04 Sat 13:59]--[2017-11-04 Sat 14:08] =>  0:09
    CLOCK: [2017-11-01 Wed 20:48]--[2017-11-01 Wed 20:55] =>  0:07
    :END:

#+BEGIN_SRC emacs-lisp 
(get-hint 'FVF)
#+END_SRC

#+RESULTS:


** MNY
   :LOGBOOK:
   CLOCK: [2017-11-01 Wed 20:55]--[2017-11-01 Wed 21:10] =>  0:15
   :END:
*** DONE VGU
    CLOSED: [2017-11-01 Wed 21:12]
#+BEGIN_SRC emacs-lisp :results silent
(defun ax+by (a x b y)
  (+ (* a x) (* b y)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
(ax+by 2 1 -1 1 )
#+END_SRC

#+RESULTS:
1
-1
30
31
61
*** DONE FVH
    CLOSED: [2017-11-01 Wed 21:16]
    :LOGBOOK:
    CLOCK: [2017-11-01 Wed 21:13]--[2017-11-01 Wed 21:16] =>  0:03
    :END:
    #+BEGIN_SRC emacs-lisp :results raw
    (require 'cl)

(defun for-some-for-some (predicate domain-x domain-y)
   (loop for x in domain-x
         thereis (loop for y in domain-y
                       thereis (funcall predicate x y))))

(let ((domain-x-y (number-sequence -49 50)))
  (for-some-for-some (lambda (x y) (= (+ (* 91 x) (* 11 y)) 1))
                     domain-x-y domain-x-y))
    #+END_SRC

    #+RESULTS:
    t
    nil
    t
    nil
    nil

*** DONE VGX 
    CLOSED: [2017-11-01 Wed 21:32]
    :LOGBOOK:
    CLOCK: [2017-11-01 Wed 21:17]--[2017-11-01 Wed 21:32] =>  0:15
    :END:
    x = ap + bq a and b > 0, p = 5 q = 7

    pq - p - q = 5(7) - 5 - 7 = 35 - 5 - 7 = 30 - 7 = 23 
*** DONE FXI
    CLOSED: [2017-11-01 Wed 21:39]
    :LOGBOOK:
    CLOCK: [2017-11-01 Wed 21:34]--[2017-11-01 Wed 21:39] =>  0:05
    :END:
    (p | ab)\rarr(p | a || p | b)

    for any integer n, if n | ab then n divides a or n divides b
** MNZ
   :LOGBOOK:
   CLOCK: [2017-11-03 Fri 20:12]--[2017-11-03 Fri 20:16] =>  0:04
   :END:
*** DONE VIB
    CLOSED: [2017-11-03 Fri 20:31]
    :LOGBOOK:
    CLOCK: [2017-11-03 Fri 20:16]--[2017-11-03 Fri 20:31] =>  0:15
    :END:

    #+BEGIN_SRC emacs-lisp :results silent
    (defun is-divisible-by (n d)
  (zerop (mod n d)))

(defun factorial (n)
  (if (zerop n)
      1
    (* n (factorial (- n 1)))))
    #+END_SRC


#+BEGIN_SRC emacs-lisp :results raw
(is-divisible-by (- (factorial 28) 28) 29)
#+END_SRC


#+RESULTS:
nil
t

    : 19


It would be the above number. Anything larger we would have to deal with integer overflow and it return null.
*** DONE FYR
    CLOSED: [2017-11-03 Fri 20:54]
    :LOGBOOK:
    CLOCK: [2017-11-03 Fri 20:32]--[2017-11-03 Fri 20:54] =>  0:22
    :END:
    We saw this in ISM determining if a number was divisable by 11. as well as the example of Wilson's Theorem.
** MN@
   :LOGBOOK:
   CLOCK: [2017-11-03 Fri 21:04]--[2017-11-03 Fri 21:22] =>  0:18
   :END:
*** DONE VIW
    CLOSED: [2017-11-03 Fri 21:22]
    :LOGBOOK:
    CLOCK: [2017-11-03 Fri 21:22]--[2017-11-03 Fri 21:23] =>  0:01
    :END:
    #+BEGIN_SRC emacs-lisp :results silent
    (require 'cl) ;; for destructuring-bind

 (defun egcd (a b)
   "Computes the greatest common divisor of a and b recursively.
    This extended version returns a list of d, x and y, where
    d = ax + by = gcd(a, b)."
   (if (zerop b)
       (list a 1 0)
       (destructuring-bind (d x y) (egcd b (% a b))
         (list d y (- x (* (/ a b) y))))))
    #+END_SRC

 #+BEGIN_SRC emacs-lisp 
 (egcd 1573428 567)
 #+END_SRC

 #+RESULTS:
 | 3 | 1 | -2775 |

 q and r are only used once each in the function, so we can just replace them with the division and mod operations instead.   
** PQT
   :LOGBOOK:
   CLOCK: [2017-11-03 Fri 21:24]--[2017-11-03 Fri 21:29] =>  0:05
   :END:
*** DONE GMQ
    CLOSED: [2017-11-03 Fri 21:50]
    :LOGBOOK:
    CLOCK: [2017-11-03 Fri 21:30]--[2017-11-03 Fri 21:49] =>  0:19
    :END:

    #+BEGIN_SRC emacs-lisp :results silent
   (defun printf (format-directive &rest args)
  (princ (apply 'format format-directive args)))
    #+END_SRC
#+BEGIN_SRC emacs-lisp :results output
(printf "%s" '"hello there" '"my name is bryan" '"these are rest args")
#+END_SRC

#+RESULTS:
: hello there

#+BEGIN_SRC emacs-lisp :results silent
(defun mystery (&rest numbers)
  (loop for n from 0 to (apply 'lcm numbers)
        do (printf "%3d <--> %s\n" n
                   (loop for m in numbers collect (mod n m)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results output
(mystery 4 6)
#+END_SRC


#+begin_example
  0 <--> (0 0)
  1 <--> (1 1)
  2 <--> (2 2)
  3 <--> (3 3)
  4 <--> (0 4)
  5 <--> (1 5)
  6 <--> (2 0)
  7 <--> (3 1)
  8 <--> (0 2)
  9 <--> (1 3)
 10 <--> (2 4)
 11 <--> (3 5)
 12 <--> (0 0)
#+end_example

#+begin_example
  0 <--> (0 0)
  1 <--> (1 1)
  2 <--> (2 2)
  3 <--> (0 3)
  4 <--> (1 4)
  5 <--> (2 0)
  6 <--> (0 1)
  7 <--> (1 2)
  8 <--> (2 3)
  9 <--> (0 4)
 10 <--> (1 0)
 11 <--> (2 1)
 12 <--> (0 2)
 13 <--> (1 3)
 14 <--> (2 4)
 15 <--> (0 0)
#+end_example

#+begin_example 
with '*
  0 <--> (0 0)
  1 <--> (1 1)
  2 <--> (2 2)
  3 <--> (0 3)
  4 <--> (1 4)
  5 <--> (2 0)
  6 <--> (0 1)
  7 <--> (1 2)
  8 <--> (2 3)
  9 <--> (0 4)
 10 <--> (1 0)
 11 <--> (2 1)
 12 <--> (0 2)
 13 <--> (1 3)
 14 <--> (2 4)
 15 <--> (0 0)
#+end_example

The function lists all the numbers from 0 to the lcm of the provided inputs along with the 
modulus of that number and the inputs. Although multiplication works, after the function passes
the lcm, the remainders repeat, so its best to just stop at the lcm. You could say that this function 
generates all possible combinations of mods of two numbers. So I would call it something like
gen-all-possible-mod-combos. We can use this for the Chinese Remainer theorem I believe.... 
*** DONE JPZ
    CLOSED: [2017-11-03 Fri 21:58]
    :LOGBOOK:
    CLOCK: [2017-11-03 Fri 21:50]--[2017-11-03 Fri 21:58] =>  0:08
    :END:
#+BEGIN_SRC emacs-lisp
(let* ((p 3)
       (q 5)
       (z-pq (number-sequence 0 (* p q))))
    (mapcar* 'list z-pq
             (mapcar (lambda (n) (mod n p)) z-pq)
             (mapcar (lambda (n) (mod n q)) z-pq)))
#+END_SRC

#+RESULTS:
|  0 | 0 | 0 |
|  1 | 1 | 1 |
|  2 | 2 | 2 |
|  3 | 0 | 3 |
|  4 | 1 | 4 |
|  5 | 2 | 0 |
|  6 | 0 | 1 |
|  7 | 1 | 2 |
|  8 | 2 | 3 |
|  9 | 0 | 4 |
| 10 | 1 | 0 |
| 11 | 2 | 1 |
| 12 | 0 | 2 |
| 13 | 1 | 3 |
| 14 | 2 | 4 |
| 15 | 0 | 0 |

It creates a table just like the previous function. The left most column lists the numbers from 0 to pq (z).
then middle column lists p%z, and the right column lists q%z from 0 to z.
It does this by creating a number sequence from 0 to pq and then mapping over that sequence, collecting the 
results of p % z_n and q % z_n. 

This function would be more functional. It uses a map instead of a loop, which means that there are no variables, 
only constant values that are used to generate new values. 
** PQU
   :LOGBOOK:
   CLOCK: [2017-11-03 Fri 21:58]--[2017-11-03 Fri 22:15] =>  0:17
   :END:
** PQV
*** DONE GMY
    CLOSED: [2017-11-04 Sat 13:50]
    :LOGBOOK:
    CLOCK: [2017-11-04 Sat 13:24]--[2017-11-04 Sat 13:50] =>  0:26
    CLOCK: [2017-11-03 Fri 22:17]--[2017-11-03 Fri 22:38] =>  0:21
    :END:
#+BEGIN_SRC emacs-lisp :results silent
(require 'cl) ;; for destructuring-bind

(defun egcd (a b)
  "Computes the greatest common divisor of a and b recursively.
   This extended version returns a list of d, x and y, where
   d = ax + by = gcd(a, b)."
  (if (zerop b)
      (list a 1 0)
    (let ((q (/ a b))
          (r (% a b)))
      (destructuring-bind (d x y) (egcd b r)
        (list d y (- x (* q y)))))))

(defun chinese-remainder-theorem (r1 r2 r3 m1 m2 m3)
(let* ((m (* m1 m2 m3))
       (o1 (/ m m1))
       (o2 (/ m m2))
       (o3 (/ m m3))
       (y1 (find-y o1 m1))
       (y2 (find-y o2 m2))
       (y3 (find-y o3 m3))
       ;;(y1 (nth 1 (egcd o1 m1)))
       ;;(y2 (nth 1 (egcd o2 m2)))
       ;;(y3 (nth 1 (egcd o3 m3)))
       )
  (mod (+ (* r1 o1 y1) (* r2 o2 y2) (* r3 o3 y3)) m)))

(defun find-y (o m)
   (let* ((equat (egcd o m)))
         (if (= (nth 0 equat) 1)
             (mod (nth 1 equat) m)
             ("no solutions"))
   ))
#+END_SRC

#+RESULTS:
893

#+BEGIN_SRC emacs-lisp :results raw
(find-y 65537 167605130703687120)
#+END_SRC

#+RESULTS:
95501447973935153
28194

#+BEGIN_SRC emacs-lisp
(chinese-remainder-theorem 4 2 9 7 11 13)
#+END_SRC

#+RESULTS:
: 893


*** DONE JQA
    CLOSED: [2017-11-04 Sat 13:51]
    :LOGBOOK:
    CLOCK: [2017-11-04 Sat 13:50]--[2017-11-04 Sat 13:51] =>  0:01
    CLOCK: [2017-11-04 Sat 13:20]--[2017-11-04 Sat 13:24] =>  0:04
    :END:
   
#+BEGIN_SRC emacs-lisp 
(chinese-remainder-theorem 3 5 4 7 11 13)
#+END_SRC 

#+RESULTS:
: 654

*** DONE GRZ
    CLOSED: [2017-11-04 Sat 13:51]
    :LOGBOOK:
    CLOCK: [2017-11-04 Sat 13:51]--[2017-11-04 Sat 13:51] =>  0:00
    :END:
#+BEGIN_SRC emacs-lisp
(chinese-remainder-theorem 3 2 1 7 11 13)
#+END_SRC

#+RESULTS:
: 794

*** DONE JYA
    CLOSED: [2017-11-04 Sat 13:53]
    #+BEGIN_SRC emacs-lisp
    (chinese-remainder-theorem 2 3 4 7 11 13)
    #+END_SRC

    #+RESULTS:
    : 212

*** GXF 
    :LOGBOOK:
    CLOCK: [2017-11-04 Sat 13:53]--[2017-11-04 Sat 13:59] =>  0:06
    :END:
#+BEGIN_SRC emacs-lisp
(chinese-remainder-theorem 0 8 12 7 11 13)
#+END_SRC

#+RESULTS:
: 987

* Halloween ICE
  1. Modular Multiplicative Inverse
  2. Modular Exponentiation
  3. Modular Arithmetic
  4. The Division Theorem
  5. Euclidean GCD, plain versus extended
  6. Alternate Base Representation
  
* Week 8 PQR 
#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2017-11-10 Fri 19:05]
| Headline            | Time   |      |
|---------------------+--------+------|
| *Total time*        | *8:06* |      |
|---------------------+--------+------|
| Week 8 PQR          | 8:06   |      |
| \_  Week 8 Day 1    |        | 1:00 |
| \_  Week 8 Day 2    |        | 0:58 |
| \_  Office Visit Qs |        | 0:26 |
| \_  PQV             |        | 1:14 |
| \_  PQW             |        | 2:48 |
| \_  PQY             |        | 1:40 |
#+END:

** Week 8 Day 1
   :LOGBOOK:
   CLOCK: [2017-11-07 Tue 10:15]--[2017-11-07 Tue 11:15] =>  0:55
   :END:
*** ICE 
    I did both. You can find them under PQW \rarr XFO in the headings
** Week 8 Day 2
   :LOGBOOK:
   CLOCK: [2017-11-09 Thu 10:18]--[2017-11-09 Thu 11:16] =>  0:58
   :END:
*** Shuffling As Scrambling

    #+BEGIN_SRC emacs-lisp
    
    #+END_SRC
** DONE Office Visit Qs
   CLOSED: [2017-11-10 Fri 18:33]
   :LOGBOOK:
   CLOCK: [2017-11-10 Fri 15:13]--[2017-11-10 Fri 15:39] =>  0:26
   :END:

*** DONE What does it have to do with 4th power of two?
    CLOSED: [2017-11-10 Fri 15:27]
*** DONE RNS Testing
    CLOSED: [2017-11-10 Fri 18:33]
*** DONE RSA... Finding d?
    CLOSED: [2017-11-10 Fri 18:33]
** DONE PQV
   CLOSED: [2017-11-10 Fri 19:05]
*** DONE XAJ
    CLOSED: [2017-11-08 Wed 20:53]
    :LOGBOOK:
    CLOCK: [2017-11-08 Wed 20:32]--[2017-11-08 Wed 20:53] =>  0:21
    :END:
#+BEGIN_SRC emacs-lisp
(chinese-remainder-theorem 0 9 2 7 11 13)
#+END_SRC

#+RESULTS:
: 119

No there are not. You can analyize the rns-alist, and you will find no result where d_1 = r_1 d_2 = r_2 d_3 = r_3
*** DONE GYI
    CLOSED: [2017-11-10 Fri 19:05]
    :LOGBOOK:
    CLOCK: [2017-11-09 Thu 21:03]--[2017-11-09 Thu 21:13] =>  0:10
    CLOCK: [2017-11-08 Wed 22:36]--[2017-11-08 Wed 22:48] =>  0:12
    CLOCK: [2017-11-08 Wed 20:53]--[2017-11-08 Wed 21:24] =>  0:31
    :END:

The set up triples is the cartesian product of [1 2] [1 4] [3 4]. Each of these adds up to one of the first three odd primes: 3 5 7.
Still working out how it relates to 2^4 
#+BEGIN_SRC emacs-lisp :results raw
(chinese-remainder-theorem 2 4 4 3 5 7)
#+END_SRC

#+RESULTS:
74
59
11
101
4
94
46
31

4, 11, 31, 46, 59, 74, 94, 101

#+BEGIN_SRC emacs-lisp
(mapcar (lambda (n) (mod (* n n) (* 15 7))) '(4 11 31 46 59 74 94 101))
#+END_SRC

#+RESULTS:
| 16 | 16 | 16 | 16 | 16 | 16 | 16 | 16 |

** DONE PQW
   CLOSED: [2017-11-10 Fri 18:56]
*** DONE XFO
    CLOSED: [2017-11-10 Fri 18:56]
    :LOGBOOK:
    CLOCK: [2017-11-10 Fri 18:42]--[2017-11-10 Fri 18:56] =>  0:14
    CLOCK: [2017-11-10 Fri 13:52]--[2017-11-10 Fri 14:09] =>  0:17
    CLOCK: [2017-11-09 Thu 20:21]--[2017-11-09 Thu 21:01] =>  0:40
    CLOCK: [2017-11-09 Thu 15:10]--[2017-11-09 Thu 15:54] =>  0:44
    CLOCK: [2017-11-09 Thu 14:59]--[2017-11-09 Thu 15:01] =>  0:02
    CLOCK: [2017-11-09 Thu 10:14]--[2017-11-09 Thu 10:18] =>  0:04
    CLOCK: [2017-11-08 Wed 22:01]--[2017-11-08 Wed 22:22] =>  0:21
    CLOCK: [2017-11-08 Wed 21:25]--[2017-11-08 Wed 21:51] =>  0:26
    :END:

**** Create a-list
     #+BEGIN_SRC emacs-lisp :results silent
   (defalias 'magic-remainder-finder '%)  

     (defun create-rns-alist-loop ()
       (loop for n from 0 to 1001
          collect (list n (mod n 7) (mod n 11) (mod n 13))))

     (defun create-rns-alist-with-mod ()
     (let* ((z-pqy (number-sequence 0 1001)))
        (mapcar* 'list z-pqy 
           (mapcar (lambda (n) (magic-remainder-finder n 7)) z-pqy)
           (mapcar (lambda (n) (magic-remainder-finder n 11)) z-pqy)
           (mapcar (lambda (n) (magic-remainder-finder n 13)) z-pqy))))
           
(defun test-rns-a-list ()
       (let* ((test (number-sequence 0 10001))
              (tests (apply #'append (make-list 143 '(0 1 2 3 4 5 6)))))
               (mapcar* 'list test tests)))
           
     (defun create-rns-alist ()
        "Hey look at this function! It makes an rns-alist table without using 
        any + - * / or % operators."
        (let* ((z-pqy (number-sequence 0 1001))
               (mod-7 (apply #'append (make-list 143 (number-sequence 0 6))))
               (mod-11 (apply #'append (make-list 91 (number-sequence 0 10))))
               (mod-13 (apply #'append (make-list 77 (number-sequence 0 12))))
               (last-term '(1001 0 0 0)))
               (append (mapcar* 'list z-pqy mod-7 mod-11 mod-13) last-term)))

     #+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
(create-rns-alist)
#+END_SRC





#+BEGIN_SRC emacs-lisp :results silent 
  (setq rns-alist (create-rns-alist-with-mod)) 
#+END_SRC

**** alist result

  #+BEGIN_SRC emacs-lisp
  (retrieve-package 'test-rns-1001)
  #+END_SRC

  #+RESULTS:
  : 3235

#+BEGIN_SRC emacs-lisp :results raw 
(require 'test-rns-1001)
(do-test-rns-add2)
#+END_SRC

#+RESULTS:
t

**** Helper functions

  #+BEGIN_SRC emacs-lisp :results silent
  (defun to-rns (n)
  (cdr (assoc n rns-alist)))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :results raw
  (to-rns 123)
  #+END_SRC

  #+RESULTS:
  (4 2 6)


  #+BEGIN_SRC emacs-lisp :results silent
  (defun from-rns (rns)
  (car (rassoc rns rns-alist)))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp :results raw
  (from-rns '(4 2 6))
  #+END_SRC

  #+RESULTS:
  123
**** DONE My add and mul
     CLOSED: [2017-11-10 Fri 18:54]

ADDING 2 RNS numbers...

#+BEGIN_SRC emacs-lisp :results silent
    (defun add2 (i j)
    (list (a7 (nth 0 i) (nth 0 j)) (a11 (nth 1 i) (nth 1 j)) (a13 (nth 2 i) (nth 2 j))))
    

    (defun mul2 (i j)
     (list (a7 (nth 0 i) (nth 0 j)) (a11 (nth 1 i) (nth 1 j)) (a13 (nth 2 i) (nth 2 j))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add2 '(1 2 3) '(2 4 5))
#+END_SRC

#+RESULTS:
| 3 | 6 | 8 |

**** Provided helper functions

     #+BEGIN_SRC emacs-lisp :results silent
     (defun a7 (i j)
  "Add two nonnegative integers in the Z_7 residue set to produce
   a sum in that set. Error check to ensure the inputs are valid,
   and use table lookup instead of normal addition/mod."
  (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 7) (< j 7))
    (error "bad parameters %s and/or %s" i j))
  (aref (aref [[0 1 2 3 4 5 6]
               [1 2 3 4 5 6 0]
               [2 3 4 5 6 0 1]
               [3 4 5 6 0 1 2]
               [4 5 6 0 1 2 3]
               [5 6 0 1 2 3 4]
               [6 0 1 2 3 4 5]] i) j))

(defun a11 (i j)
  "Add two nonnegative integers in the Z_11 residue set to produce
   a sum in that set. Error check to ensure the inputs are valid,
   and use table lookup instead of normal addition/mod."
  (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 11) (< j 11))
    (error "bad parameters %s and/or %s" i j))
  (aref (aref [[ 0  1  2  3  4  5  6  7  8  9 10]
               [ 1  2  3  4  5  6  7  8  9 10  0]
               [ 2  3  4  5  6  7  8  9 10  0  1]
               [ 3  4  5  6  7  8  9 10  0  1  2]
               [ 4  5  6  7  8  9 10  0  1  2  3]
               [ 5  6  7  8  9 10  0  1  2  3  4]
               [ 6  7  8  9 10  0  1  2  3  4  5]
               [ 7  8  9 10  0  1  2  3  4  5  6]
               [ 8  9 10  0  1  2  3  4  5  6  7]
               [ 9 10  0  1  2  3  4  5  6  7  8]
               [10  0  1  2  3  4  5  6  7  8  9]] i) j))

(defun a13 (i j)
  "Add two nonnegative integers in the Z_13 residue set to produce
   a sum in that set. Error check to ensure the inputs are valid,
   and use table lookup instead of normal addition/mod."
  (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 13) (< j 13))
    (error "bad parameters %s and/or %s" i j))
  (aref (aref [[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
               [ 1  2  3  4  5  6  7  8  9 10 11 12  0]
               [ 2  3  4  5  6  7  8  9 10 11 12  0  1]
               [ 3  4  5  6  7  8  9 10 11 12  0  1  2]
               [ 4  5  6  7  8  9 10 11 12  0  1  2  3]
               [ 5  6  7  8  9 10 11 12  0  1  2  3  4]
               [ 6  7  8  9 10 11 12  0  1  2  3  4  5]
               [ 7  8  9 10 11 12  0  1  2  3  4  5  6]
               [ 8  9 10 11 12  0  1  2  3  4  5  6  7]
               [ 9 10 11 12  0  1  2  3  4  5  6  7  8]
               [10 11 12  0  1  2  3  4  5  6  7  8  9]
               [11 12  0  1  2  3  4  5  6  7  8  9 10]
               [12  0  1  2  3  4  5  6  7  8  9 10 11]] i) j))

(defun m7 (i j)
  "Multiply two nonnegative integers in the Z_7 residue set to produce
   a product in that set. Error check to ensure the inputs are valid,
   and use table lookup instead of normal multiplication/mod."
  (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 7) (< j 7))
    (error "bad parameters %s and/or %s" i j))
  (aref (aref [[0  0  0  0  0  0  0]
               [0  1  2  3  4  5  6]
               [0  2  4  6  1  3  5]
               [0  3  6  2  5  1  4]
               [0  4  1  5  2  6  3]
               [0  5  3  1  6  4  2]
               [0  6  5  4  3  2  1]] i) j))

(defun m11 (i j)
  "Multiply two nonnegative integers in the Z_11 residue set to produce
   a product in that set. Error check to ensure the inputs are valid,
   and use table lookup instead of normal multiplication/mod."
  (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 11) (< j 11))
    (error "bad parameters %s and/or %s" i j))
  (aref (aref [[0  0  0  0  0  0  0  0  0  0  0]
               [0  1  2  3  4  5  6  7  8  9 10]
               [0  2  4  6  8 10  1  3  5  7  9]
               [0  3  6  9  1  4  7 10  2  5  8]
               [0  4  8  1  5  9  2  6 10  3  7]
               [0  5 10  4  9  3  8  2  7  1  6]
               [0  6  1  7  2  8  3  9  4 10  5]
               [0  7  3 10  6  2  9  5  1  8  4]
               [0  8  5  2 10  7  4  1  9  6  3]
               [0  9  7  5  3  1 10  8  6  4  2]
               [0 10  9  8  7  6  5  4  3  2  1]] i) j))

(defun m13 (i j)
  "Multiply two nonnegative integers in the Z_13 residue set to produce
   a product in that set. Error check to ensure the inputs are valid,
   and use table lookup instead of normal multiplication/mod."
  (unless (and (integerp i) (integerp j) (<= 0 i) (<= 0 j) (< i 13) (< j 13))
    (error "bad parameters %s and/or %s" i j))
  (aref (aref [[0  0  0  0  0  0  0  0  0  0  0  0  0]
               [0  1  2  3  4  5  6  7  8  9 10 11 12]
               [0  2  4  6  8 10 12  1  3  5  7  9 11]
               [0  3  6  9 12  2  5  8 11  1  4  7 10]
               [0  4  8 12  3  7 11  2  6 10  1  5  9]
               [0  5 10  2  7 12  4  9  1  6 11  3  8]
               [0  6 12  5 11  4 10  3  9  2  8  1  7]
               [0  7  1  8  2  9  3 10  4 11  5 12  6]
               [0  8  3 11  6  1  9  4 12  7  2 10  5]
               [0  9  5  1 10  6  2 11  7  3 12  8  4]
               [0 10  7  4  1 11  8  5  2 12  9  6  3]
               [0 11  9  7  5  3  1 12 10  8  6  4  2]
               [0 12 11 10  9  8  7  6  5  4  3  2  1]] i) j))
     #+END_SRC
     
**** Testing RNS
#+BEGIN_SRC emacs-lisp :results output
(require 'test-rns-1001)
(if (and (do-test-rns-add2) (do-test-rns-mul2)) 
(print "test passed") (print "test failed"))
#+END_SRC

#+RESULTS:
: 
: "test passed"

** DONE PQY
   CLOSED: [2017-11-10 Fri 18:40]
*** DONE GYN
    CLOSED: [2017-11-10 Fri 18:40]
    #+BEGIN_SRC emacs-lisp :results silent
(defun pow-mod (base power modulus)
   (let* ((result 1)
      (base (mod base modulus)))
      (while (> power 0)
        (when (oddp power)
        (setq result (mod (* result base) modulus)))
        (setq base (mod (* base base) modulus)
              power (/ power 2))
      ) result ))

#+END_SRC
*** DONE XGG
    CLOSED: [2017-11-10 Fri 18:40]
    :LOGBOOK:
    CLOCK: [2017-11-10 Fri 18:21]--[2017-11-10 Fri 18:40] =>  0:19
    CLOCK: [2017-11-10 Fri 14:09]--[2017-11-10 Fri 14:57] =>  0:48
    CLOCK: [2017-11-09 Thu 21:14]--[2017-11-09 Thu 21:40] =>  0:26
    CLOCK: [2017-11-09 Thu 15:01]--[2017-11-09 Thu 15:08] =>  0:07
    :END:

**** RSA Encrypt
     #+BEGIN_SRC emacs-lisp :results silent
 (defun pow-mod (base power modulus)
   (let* ((result 1)
      (base (mod base modulus)))
      (while (> power 0)
        (when (oddp power)
        (setq result (mod (* result base) modulus)))
        (setq base (mod (* base base) modulus)
              power (/ power 2))
      ) result ))
   

 (defun rsa-encrypt (message n e &optional encoder)
  (let* ((message-encoded (funcall (or encoder 'identity) message))
         (encrypted (pow-mod message-encoded e n)))
    encrypted))

(defun rsa-decrypt (encrypted n d &optional decoder)
  (let* ((decrypted (pow-mod encrypted d n))
         (message-decoded (funcall (or decoder 'identity) decrypted)))
    message-decoded))

(defun round-trip (message n e d &optional encoder decoder)
  (equal message
         (rsa-decrypt (rsa-encrypt message n e encoder)
                      n d decoder)))

(defalias 'div '/)

(defun abr (n b)
  (let ((d (div n b))
        (m (mod n b)))
    (if (zerop d)
        (list m)
      (append (abr d b) (list m)))))

(defun to-base-27 (num-base-10)
   (mapconcat (lambda (n) (char-to-string (+ ?@ n))) (abr num-base-10 27) ""))

(defun from-base-27 (string-base-27) 
    (reconstruct-number-from-abr (reverse (mapcar (lambda (n) (- n ?@)) string-base-27)) 27))

(defun reconstruct-number-from-abr (list-of-coeff base)
   (if (null list-of-coeff)
      0
      (+ (car list-of-coeff)
         (* base (reconstruct-number-from-abr (cdr list-of-coeff) base)))))

     #+END_SRC
**** First Three Functions
#+BEGIN_SRC emacs-lisp
(rsa-encrypt 25 (* 3 11) 3)
#+END_SRC

#+RESULTS:
: 16

#+BEGIN_SRC emacs-lisp
(rsa-decrypt 16 (* 3 11) 7)
#+END_SRC

#+RESULTS:
: 25

#+BEGIN_SRC emacs-lisp :results raw
(round-trip 83 (* 11 17) 3 107)
#+END_SRC

#+RESULTS:
t
t
t
**** Test RSA

This was for testing purposes...
#+BEGIN_SRC emacs-lisp
(egcd 65537 167605130703687120)
#+END_SRC

#+RESULTS:
| 1 | -72103682729751967 | 28194 |


This will encrypt very small messages... I tried to some larger ones, but I had problems with overflow that
messed up the encryption. To encrypt larger messages, simply make p and q larger primes. You will then need to find 
the coprimes e and d. 
#+BEGIN_SRC emacs-lisp
(setf (get 'rsa-players :p) 11)
(setf (get 'rsa-players :q) 17)
(setf (get 'rsa-players :n) (* (get 'rsa-players :p) (get 'rsa-players :q)))
(setf (get 'rsa-players :t) (* (- (get 'rsa-players :p) 1) (- (get 'rsa-players :q) 1)))
(setf (get 'rsa-players :e) '13)
(setf (get 'rsa-players :d) '37)


(defun test-rsa (message-with-spaces)
  (let* ((message (mapconcat 'identity
                             (split-string message-with-spaces " ") "@"))
          (n (get 'rsa-players :n))
          (e (get 'rsa-players :e))
          (d (get 'rsa-players :d))
          (encrypted (rsa-encrypt message n e 'from-base-27))
          (decrypted (rsa-decrypt encrypted n d 'to-base-27))
          (decrypted-message-with-spaces
           (mapconcat 'identity (split-string decrypted "@") " "))
          (success (string= message-with-spaces
                            decrypted-message-with-spaces)))
     (princ (format (concat "\"%s\"\nwas encoded and encrypted as\n%s\n"
                            "then decrypted and decoded as\n\"%s\"\n")
                    message-with-spaces
                    encrypted
                    decrypted-message-with-spaces))
     (princ (if success "" "un"))
     (princ "successfully.\n")
     success))

#+END_SRC

#+RESULTS:
: test-rsa

#+BEGIN_SRC emacs-lisp :results output
(test-rsa "BJ")
#+END_SRC

#+RESULTS:
: "BJ"
: was encoded and encrypted as
: 47
: then decrypted and decoded as
: "BJ"
: successfully.

#+BEGIN_SRC emacs-lisp
(get 'rsa-players :t)
#+END_SRC

#+RESULTS:
: 160

#+BEGIN_SRC emacs-lisp
most-positive-fixnum
#+END_SRC

#+RESULTS:
: 2305843009213693951

#+BEGIN_SRC emacs-lisp
(from-base-27 "AB")
#+END_SRC

#+RESULTS:
: 29
* Week 9 STU Pt 1.
#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2017-11-18 Sat 13:58]
| Headline                             | Time   |      |
|--------------------------------------+--------+------|
| *Total time*                         | *7:50* |      |
|--------------------------------------+--------+------|
| Week 9 STU Pt 1.                     | 7:50   |      |
| \_  Logbook for the reading portions |        | 1:18 |
| \_  Week 9 Day 1                     |        | 1:02 |
| \_  Week 9 Day 2                     |        | 1:06 |
| \_  STX                              |        | 0:40 |
| \_  ST@                              |        | 1:20 |
| \_  STC                              |        | 0:41 |
| \_  STD                              |        | 1:20 |
| \_  STH                              |        | 0:23 |
#+END:

** Logbook for the reading portions
  :LOGBOOK:
  CLOCK: [2017-11-18 Sat 13:51]--[2017-11-18 Sat 13:58] =>  0:07
  CLOCK: [2017-11-17 Fri 18:07]--[2017-11-17 Fri 18:49] =>  0:42
  CLOCK: [2017-11-14 Tue 18:20]--[2017-11-14 Tue 18:21] =>  0:01
  CLOCK: [2017-11-14 Tue 17:42]--[2017-11-14 Tue 17:48] =>  0:06
  CLOCK: [2017-11-13 Mon 20:38]--[2017-11-13 Mon 20:54] =>  0:16
  CLOCK: [2017-11-13 Mon 19:57]--[2017-11-13 Mon 20:03] =>  0:06
  :END:
** Week 9 Day 1
   :LOGBOOK:
   CLOCK: [2017-11-14 Tue 10:14]--[2017-11-14 Tue 11:16] =>  1:02
   :END:
*** egcd
a new egcd. Added conditional if mod = 1
*** XGG

    A new version of the powmod function
*** ICE on LJP
** Week 9 Day 2
   :LOGBOOK:
   CLOCK: [2017-11-16 Thu 10:08]--[2017-11-16 Thu 11:14] =>  1:06
   :END:
*** BSTs 
**** How many BSTs are there with 1 node?
     Just one :)

     | n | How many BSTs? | Computed via (2n)!/(n+1)!n! |
     |---+----------------+-----------------------------|
     | 1 |              1 | 2/2*1=1                     |
     | 2 |              2 | (4*3*2*1) / (3*4) = 2       |
     | 3 |              5 |                             |
     | 4 |             14 |                             |
     | 5 |             42 |                             |

**** 
** DONE STX
   CLOSED: [2017-11-14 Tue 16:23]
*** DONE LDA
    CLOSED: [2017-11-13 Mon 20:06]
    :LOGBOOK:
    CLOCK: [2017-11-13 Mon 20:03]--[2017-11-13 Mon 20:06] =>  0:03
    :END:
    #+BEGIN_SRC emacs-lisp :results raw
    (let ((a 1) (b 2) (c 3) (d 4))
  (cons (+ a b) (cons (/ d b) (cons (- d a) (cons (* c d) nil)))))
    #+END_SRC

    #+RESULTS:
    (3 2 3 12)
*** DONE SQI
    CLOSED: [2017-11-13 Mon 20:13]
    :LOGBOOK:
    CLOCK: [2017-11-13 Mon 20:06]--[2017-11-13 Mon 20:13] =>  0:07
    :END:

    #+BEGIN_SRC emacs-lisp
    (defun morphifyr (fun lst)
  (if (null lst)
      nil
    (append (list (funcall fun (first lst))) (morphifyr fun (rest lst)))))

    (defun morphifyr-cons (fun lst)
       (if (null lst)
        nil
       (cons (funcall fun (first lst)) (morphifyr fun (rest lst)))))
    #+END_SRC

    #+RESULTS:
    : morphifyr-cons

#+BEGIN_SRC emacs-lisp :results raw
(equal (morphifyr-cons (lambda (n) (+ n 1)) '(1 2 3 4)) (morphifyr (lambda (n) (+ n 1)) '(1 2 3 4)))
#+END_SRC

#+RESULTS:
t
t
(2 3 4 5)
(2 3 4 5)
*** DONE LJP
    CLOSED: [2017-11-14 Tue 16:23]
    :LOGBOOK:
    CLOCK: [2017-11-14 Tue 16:17]--[2017-11-14 Tue 16:23] =>  0:06
    CLOCK: [2017-11-13 Mon 20:13]--[2017-11-13 Mon 20:37] =>  0:24
    :END:

Think recursively...


97
#+BEGIN_SRC emacs-lisp :results silent
(defun prime-list-from-rle-list (rle-list limit)
  (mapcar 'first
          (remove-if
           (lambda (x)
             (zerop (second x)))
           (mapcar* 'list
                    (number-sequence 2 limit)
                    (apply 'append
                           (mapcar (lambda (x)
                                     (if (> x 1)
                                         (make-list x 0)
                                       (list x)))
                                   rle-list))))))

(defun reconstitute-primes (rle-list)
  (loop for b in rle-list
        for n from 2
        unless (or (zerop b) (and (> b 1) (incf n (- b 1))))
        collect n))


(defun prime-list-from-rle-list-cons (start rle-list)
  ;; 1. (Null rle list)
  ;; 2. (zerop (car rle-list))
  ;; 3. (= 1 (car rle-list)) cons something
  ;; 4. (> (car rle-list) 1)
  (cond ((null rle-list) nil)
        ((zerop (car rle-list))
          (prime-list-from-rle-list-cons (+ start 1) (cdr rle-list)))
        ((= 1 (car rle-list)) 
         (cons (+ start 1) (prime-list-from-rle-list-cons (+ start 1) (cdr rle-list))))
        ((> (car rle-list) 1) (prime-list-from-rle-list-cons (+ start (car rle-list)) (cdr rle-list)))
  ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(prime-list-from-rle-list-cons 1 p100rle)
#+END_SRC

#+RESULTS:
| 2 | 3 | 5 | 7 | 11 | 13 | 17 | 19 | 23 | 29 | 31 | 37 | 41 | 43 | 47 | 53 | 59 | 61 | 67 | 71 | 73 | 79 | 83 | 89 | 97 |

#+BEGIN_SRC emacs-lisp :results raw
(setq limit 0
      p100rle (list 1 1 0 1 0 1 3 1 0 1 3 1 0 1 3 1 5 1 0 1 5 1 3 1 0
                    1 3 1 5 1 5 1 0 1 5 1 3 1 0 1 5 1 3 1 5 1 7 1 3)
      got-it-right (equal (reconstitute-primes p100rle)
                          (prime-list-from-rle-list-cons 1 p100rle)))
#+END_SRC

#+RESULTS:
t
nil
(2 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49)
(2 3 5)
(2 3 5)
nil
** DONE ST@
   CLOSED: [2017-11-14 Tue 17:41]
*** DONE SUF
    CLOSED: [2017-11-14 Tue 17:11]
    :LOGBOOK:
    CLOCK: [2017-11-14 Tue 16:24]--[2017-11-14 Tue 17:11] =>  0:47
    CLOCK: [2017-11-13 Mon 20:54]--[2017-11-13 Mon 21:03] =>  0:09
    :END:

    #+BEGIN_SRC emacs-lisp :results silent
    (defun number-of-factors (csf)
  "Takes a CSF like '((2 . 3) (3 . 1) (5 . 2)) and returns 24."
  (apply #'* (mapcar (lambda (n) (+ 1 (cdr n) )) csf)))


    #+END_SRC



#+BEGIN_SRC emacs-lisp :results raw
(number-of-factors '((2 . 3) (3 . 2) (5 . 1)))
#+END_SRC

#+RESULTS:
24
*** DONE LNR
    CLOSED: [2017-11-14 Tue 17:41]
    :LOGBOOK:
    CLOCK: [2017-11-14 Tue 17:12]--[2017-11-14 Tue 17:36] =>  0:24
    :END:

    #+BEGIN_SRC emacs-lisp
    (defun number-of-factors-alt (csf)
  "Takes a CSF like [(2 3) (3 1) (5 2)] and returns 24."
    (apply #'* (mapcar (lambda (n) (+ 1 (car (cdr n)))) csf)))
    #+END_SRC

    #+RESULTS:
    : number-of-factors-alt


    #+BEGIN_SRC emacs-lisp :results raw
    (number-of-factors-alt [(2 3) (3 1) (5 2)])
    #+END_SRC

    #+RESULTS:
    24
    24
** STC 
*** YGT
    :LOGBOOK:
    CLOCK: [2017-11-14 Tue 17:48]--[2017-11-14 Tue 17:53] =>  0:05
    :END:

    It has a height of 4

                             time
                            /    \ 
                       flies      wings
                            \
                             on
                            /
                          of
                         / 
                      lightning   
*** LDO
    :LOGBOOK:
    CLOCK: [2017-11-17 Fri 15:39]--[2017-11-17 Fri 16:00] =>  0:21
    CLOCK: [2017-11-14 Tue 18:04]--[2017-11-14 Tue 18:19] =>  0:15
    :END:
    Case 1: The key is a leaf on the tree. We simply delete the leaf without needing to further modify the tree
    Case 2: The key has one child. We change the parent of the key to point to the child of the key, and then remove the key.
    Case 3: The key has two children. Find the next largest item by traversing to the left down the key's right subtree. When a node with no left child is found, 
            we have found the next largest item. Recursively remove this item, and use it to replace the key. You must do this recursively, because it is possible 
            that in moving that node, you will need to adjust its children.

    Deletion is not always as fast. It is only as fast if the key to delete is a leaf. Otherwise, time will be spent readjusting the tree.
** STD
*** YCF
    :LOGBOOK:
    CLOCK: [2017-11-14 Tue 18:22]--[2017-11-14 Tue 18:37] =>  0:15
    :END:
**** Full Binary Tree
     A full binary tree means that every node EXCEPT the leaves has two children.
     This means there are no nodes with only one child.
**** Complete Binary Tree
     A binary tree which is completely filled except for possibly the last level. 
     The bottom level is filled from left to right. 
     A complete binary tree is very regular, and could be stored in an array if desired.

     Some cool properties of Complete Binary Trees I found: http://cs-study.blogspot.com/2012/11/complete-binary-tree.html
**** Balanced Binary Tree
     A tree is balanced if the left and subtree heights differ by 1 at the most,
     with this definition being recursively applied to each subtree. 
*** LUM
    :LOGBOOK:
    CLOCK: [2017-11-14 Tue 18:40]--[2017-11-14 Tue 18:53] =>  0:13
    :END:

This is a complete binary tree. 

I used this site to help build a visual representation of the tree: https://www.cs.usfca.edu/~galles/visualization/BST.html
*** YZU
    :LOGBOOK:
    CLOCK: [2017-11-17 Fri 16:03]--[2017-11-17 Fri 16:47] =>  0:44
    CLOCK: [2017-11-16 Thu 09:57]--[2017-11-16 Thu 10:05] =>  0:08
    :END:
**** Examples of self balancing trees (balance at insertion)
     https://www.cpp.edu/~ftang/courses/CS241/notes/self%20balance%20bst.htm
***** AVL trees
      Checks at insertion that all tree rules are followed, with a balance factor of 1, 0, or -1.
      Will rotate tree after insertion. Due to implementation, at most 2 rotations will be needed to rebalance the tree.
***** Red Black tree
      Every node is either 'red' or 'black'
      Root of the tree is always black
      There are no two adjacent red nodes
      Every path from root to a null node has the same amount of black nodes. This keeps the tree roughly balanced.
      The tree is recursively balanced by repainting nodes as necessary, cascading up the tree. 
**** Balancing an unbalanced tree
***** Insertion
      One method to balance an unbalanced tree, would be to traverse the unbalanced tree, and insert each node into an AVL like
      tree, thus balancing it. This is a simple solution, but not always the most efficient. Depending on the complexity of the tree,
      this may or may not work. 
***** Other options
      Traverse the unbalanced tree and store the result in an array. Sort the array, and then insert it as a balanced binary tree. 
** STH
*** DONE LTI   
    CLOSED: [2017-11-20 Mon 23:10]
     :LOGBOOK:
       CLOCK: [2017-11-18 Sat 13:25]--[2017-11-18 Sat 13:48] =>  0:23
     :END:
**** Decode function
      #+BEGIN_SRC emacs-lisp
      (require 'cl)

 (defvar huff-tree
   '((("n" "t") (("i" "o") (" " ""))) ("e" ("h" "r"))))

 (defun get-value (node)
   (and (stringp node) node))

 (defun get-left (node)
   (and (listp node) (first node)))

 (defun get-right (node)
   (and (listp node) (second node)))

 (defun find-leaf (encoded tree)
   (if (get-value tree)
       (cons tree encoded)
     (let ((first-char (elt encoded 0))
           (rest-of-encoded (substring encoded 1)))
       (case first-char
         (?0 (find-leaf rest-of-encoded (get-left tree)))
         (?1 (find-leaf rest-of-encoded (get-right tree)))
         (t "")))))

 (defvar encode1 "00010010000111010111011011010111100110000010111101100011101011110")
 (defvar encode2 "0001001000111001110101110110110101111001100000101111011000111010111100111")

 (defun huffman-decoder (encoded tree)
   (if (equal encoded "")
       ""
       (let ((leaf-cell (find-leaf encoded tree)))
       ;;   (print leaf-cell)
          (cons (car leaf-cell) (huffman-decoder (cdr leaf-cell) tree)))))

      #+END_SRC

      #+RESULTS:
      : huffman-decoder

**** Decode first message

 #+BEGIN_SRC emacs-lisp :results raw
 (huffman-decoder encode1 huff-tree)
 #+END_SRC

 #+RESULTS:
 (n e i t h e r   h e r e   n o r   t h e r e . )


**** DONE Decode second message
     CLOSED: [2017-11-20 Mon 23:10]

#+BEGIN_SRC emacs-lisp :results raw
(huffman-decoder encode2 huff-tree)
#+END_SRC

#+RESULTS:
(n e i  t h e r   h e r e   n o r   t h e r e  . )

There are extra spaces in the message, which would account for the longer encoding, and the very close result

* Week 10 STU Pt 2 VWX Pt 1

#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2017-11-24 Fri 23:09]
| Headline                  | Time   |      |
|---------------------------+--------+------|
| *Total time*              | *4:14* |      |
|---------------------------+--------+------|
| Week 10 STU Pt 2 VWX Pt 1 | 4:14   |      |
| \_  Reading               |        | 0:31 |
| \_  Week 10 Day 1         |        | 1:05 |
| \_  STI                   |        | 0:46 |
| \_  STJ                   |        | 1:07 |
| \_  STK                   |        | 0:21 |
| \_  VWD                   |        | 0:21 |
| \_  VWF                   |        | 0:03 |
#+END:

** Reading
   :LOGBOOK:
   CLOCK: [2017-11-24 Fri 23:05]--[2017-11-24 Fri 23:09] =>  0:04
   CLOCK: [2017-11-24 Fri 22:56]--[2017-11-24 Fri 23:01] =>  0:05
   CLOCK: [2017-11-24 Fri 22:22]--[2017-11-24 Fri 22:34] =>  0:12
   CLOCK: [2017-11-22 Wed 13:39]--[2017-11-22 Wed 13:40] =>  0:01
   CLOCK: [2017-11-20 Mon 23:25]--[2017-11-20 Mon 23:27] =>  0:02
   CLOCK: [2017-11-20 Mon 23:04]--[2017-11-20 Mon 23:11] =>  0:07
   :END:

** Week 10 Day 1
   :LOGBOOK:
   CLOCK: [2017-11-21 Tue 10:10]--[2017-11-21 Tue 11:15] =>  1:05
   :END:
   
*** Answer why draw all 14 valid BSTs with 4 orderable keys?
    BST Optimization

*** Huffman Trees discussion

    
**** Count Chars
     | Char | Count |
     |------+-------|
     | A    |     1 |
     | E    |     4 |
     | H    |     2 |
     | L    |     4 |
     | S    |     6 |

**** Build  Huffman tree

     A1 H2 E4 L4 S6
     AH3 E4 L4 S6
     L4 S6 AHE7
     AHE7 LS10
     AHELS17

     | CHAR | CODE |
     |------+------|
     | A    |  000 |
     | H    |  001 |
     | E    |   01 |
     | L    |   10 |
     | S    |   11 |
   
**** Create the Code 
     | CHAR | CODE | Length of Code | Count | Weighted |
     |------+------+----------------+-------+----------|
     | A    |  000 |              3 |     1 |        3 |
     | H    |  001 |              3 |     2 |        6 |
     | E    |   01 |              2 |     4 |        8 |
     | L    |   10 |              2 |     4 |        8 |
     | S    |   11 |              2 |     6 |       12 |
     |------+------+----------------+-------+----------|
     |      |      |             12 |    17 |       37 |

**** Average # of bits 

#+BEGIN_SRC emacs-lisp 
(/ 37 (float 17))
#+END_SRC

#+RESULTS:
: 2.176470588235294

**** Encode the Message
     
     1100101110110101111010001100101101011 
 
** STI
*** DONE YDQ 
    CLOSED: [2017-11-22 Wed 11:30]
    :LOGBOOK:
    CLOCK: [2017-11-22 Wed 13:20]--[2017-11-22 Wed 13:31] =>  0:11
    CLOCK: [2017-11-22 Wed 11:08]--[2017-11-22 Wed 11:30] =>  0:22
    CLOCK: [2017-11-20 Mon 23:12]--[2017-11-20 Mon 23:25] =>  0:13
    :END:
    
**** Tie Breaking Rule
     Sort first by subtree weight. Then alphabetical.
     The tiebreaker is the alphabetical order of the letters. We see that that H,F,P, and W all have an occurance
     of 1. So we order them in alphabetical order as so, F, H, P, W

**** Implement in elisp
     #+BEGIN_SRC emacs-lisp :results silent
     (defun huffman-tiebreaker (n1 n2)
     "Returns the smaller of two cons cell with a string and weight sorted lexicographically"
     (cond ((and (not (stringp (car n1))) (not (stringp (car n2))))  nil)
           ((< (cdr n1) (cdr n2)) n1)
           ((> (cdr n1) (cdr n2)) n2)
           ((< (length (car n1)) (length (car n2))) n1)
           ((> (length (car n1)) (length (car n2))) n2)
           ((string-lessp (car n1) (car n2)) n1)
           (t n2)
     ))
     #+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
(huffman-tiebreaker '("AC" . 3) '("BC" . 2))
#+END_SRC

#+RESULTS:
(BC . 2)

**** Does it matter which tiebreaker you use?
     Yes. Depending on the tie breaker, your average number of bits per character could change. This was demonstrated in class
** STJ
*** DONE LND
    CLOSED: [2017-11-22 Wed 12:05]
    :LOGBOOK:
    CLOCK: [2017-11-22 Wed 11:30]--[2017-11-22 Wed 12:05] =>  0:35
    :END:

    When looking at the ASCII binary values of these 17 char, we see
    that their values range from 01000000 to 01010111 (This range includes
    some numbers we aren't using, but that is irrelevant). Each of these numbers has
    a leading 010, which we could chop off by fixed-length encoding rules, leaving a 
    5-bit number. Additionally, 17 in binary is a 5 bit length (10001). 
    
    The general case is a little more difficult to predict when using ASCII. It depends on which range of 
    characters you need to be able to represent. In order to shorten a fixed length encoding,
    you need to be able to eliminate preceding bits that are common amongst all characters
    being represented. For instance, lets look at trying to encode my name with its real spelling: Bryan MÃ¼ller
    We would need the characters ranging from binary values of 00100000 (space) to 11111100 (Ã¼). This would give
    us a fixed length encoding of 7 bits because all seven bits would be needed to represent all of the ASCII values
    within the string. Now assuming you were not restricted to ASCII code values, you could represent my 12 char name with
    a 4 bit fixed-length encoding (12 in binary is 1100). So for the optimal general case where you are allowed to create your own encoding scheme,
    a message with n characters could be represented with a fixed length encoding of the length of n when represented in binary. This would provide 
    the possibility for a message of length n to consist of completely unique characters, and still have room to represent each character with a unique 
    binary number. 
*** DONE YTR
    CLOSED: [2017-11-22 Wed 13:20]
    :LOGBOOK:
    CLOCK: [2017-11-22 Wed 12:54]--[2017-11-22 Wed 13:20] =>  0:26
    CLOCK: [2017-11-22 Wed 12:05]--[2017-11-22 Wed 12:05] =>  0:00
    :END:
**** Count Chars 
     | Char | Count |
     |------+-------|
     | c    |     1 |
     | b    |     1 |
     | k    |     3 |
     | n    |     1 |
     | o    |     6 |
**** Build Huffman Tree

     c1 b1 n1 k3 o6
     n1 bc2 k3 o6
     k3 bcn3 o6
     o6 bcnk6
     bcnko12
 | Char | code | Length of Code | Count | Weighted |
 |------+------+----------------+-------+----------|
 | c    | 1111 |              4 |     1 |        4 |
 | b    | 1110 |              4 |     1 |        4 |
 | k    |   10 |              2 |     3 |        6 |
 | n    |  110 |              3 |     1 |        3 |
 | o    |    0 |              1 |     6 |        6 |
 |------+------+----------------+-------+----------|
 |      |      |             14 |    12 |       23 |
**** Bitstring encoding

     #+BEGIN_SRC js :results output
     String.prototype.replaceAll = function(search, replacement) {
       let target = this;
       return target.split(search).join(replacement);
    };

    let msg = 'cookbooknook';
    msg = msg.replaceAll('c','1111');
    msg = msg.replaceAll('b','1110');
    msg = msg.replaceAll('k','10');
    msg = msg.replaceAll('n','110');
    msg = msg.replaceAll('o','0');

    console.log(msg);
     #+END_SRC

     #+RESULTS:
     : 11110010111000101100010

**** Average # bits
     #+BEGIN_SRC emacs-lisp
     (setq ytr-avg-bits (/ 23 (float 12)))
     #+END_SRC

     #+RESULTS:
     : 1.9166666666666667

**** Compression Ratio

     #+BEGIN_SRC emacs-lisp
    (* (/ (- 3 ytr-avg-bits) 3) 100 )
     #+END_SRC

     #+RESULTS:
     : 36.11111111111111

     So about 36.1%
*** DONE LGO
    CLOSED: [2017-11-22 Wed 13:37]
    :LOGBOOK:
    CLOCK: [2017-11-22 Wed 13:31]--[2017-11-22 Wed 13:37] =>  0:06
    :END:
          
          n        b 
        _____   _______
    1 0 1 1 0 0 1 1 1 0
    ___       _
     k        o

     knob
** STK
*** YIV
    :LOGBOOK:
    CLOCK: [2017-11-22 Wed 13:50]--[2017-11-22 Wed 14:04] =>  0:14
    CLOCK: [2017-11-22 Wed 13:40]--[2017-11-22 Wed 13:47] =>  0:07
    :END:
    
    #+BEGIN_SRC emacs-lisp :results silent
    (require 'cl)

(defun get-value (node)
  (and (symbolp node) (symbol-value node)))

(defun set-value (node new-value)
  (and (symbolp node) (set node new-value)))

(defun get-parent (node)
  (and (symbolp node) (get node :parent)))

(defun set-parent (node parent)
  (and (symbolp node) (symbolp parent) (put node :parent parent)))

(defun get-left (node)
  (and (symbolp node) (get node :left)))

(defun set-left (node left)
  (and (symbolp node) (symbolp left) (put node :left left)))

(defun get-right (node)
  (and (symbolp node) (get node :right)))

(defun set-right (node right)
  (and (symbolp node) (symbolp right) (put node :right right)))

(defun try-it-out ()
  (setq a 1 b 2 c 3)
  (put 'a :right 'b)
  (put 'a :left 'c)
  (put 'c :parent 'a)
  (put 'b :parent 'a)
  (list a (symbol-plist 'a)))

(defvar node-counter 0)

(defun make-node ()
  (let ((symbol (intern (concat "n" (number-to-string node-counter)))))
    (set symbol node-counter)
    (incf node-counter)
    (setf (symbol-plist symbol) nil)
    symbol))

(defun build-tree (height)
  (let ((root (make-node)))
    (if (> height 0)
        (let ((left (build-tree (1- height)))
              (right (build-tree (1- height))))
          (set-left root left)
          (set-right root right)
          (set-parent left root)
          (set-parent right root)))
    root))
    #+END_SRC


#+BEGIN_SRC emacs-lisp :results raw 
(try-it-out)
#+END_SRC

#+RESULTS:
(1 (:right b :left c))


#+BEGIN_SRC emacs-lisp :results raw 
(build-tree 2)
#+END_SRC

#+RESULTS:
n41
n10
n3
n0

I drew out these trees on paper.  
** VWD
*** DONE HST
    CLOSED: [2017-11-24 Fri 23:01]
    :LOGBOOK:
    CLOCK: [2017-11-24 Fri 22:34]--[2017-11-24 Fri 22:36] =>  0:02
    :END:
    Cycles imply the existence of more than one path, because if a node is gone through twice, then it could just
    as easily have only been touched once, skipping the redundant step (unless there are some special path rules). This indeicates that their may
    be more than one valid path to the destination node. 
*** TODO KDB
    :LOGBOOK:
    CLOCK: [2017-11-24 Fri 22:37]--[2017-11-24 Fri 22:56] =>  0:19
    :END:
List in lisp form all the simple paths (in both representations) from MT to NM, identifying the shortest path(s) and the longest path(s).
    #+BEGIN_SRC emacs-lisp
    (setq kdb-arcs '([ID MT] [ID WY] [ID NV] [ID UT] [MT WY] [WY UT] [WY CO]
                     [UT CO] [UT NV] [UT AZ] [CO NM] [AZ NM] [NV AZ])
          MT-NM-paths '(([MT WY] [WY CO] [CO NM])
                        ([MT ID] [ID WY] [WY CO] [CO NM])
                        ([MT ID] [ID UT] [UT WY] [WY CO] [CO NM])
                        ([MT ID] [ID WY] [WY CO] [CO UT] [UT NV] [NV AZ] [AZ NM])
                        ())           
    )

 
    #+END_SRC

    #+RESULTS:
    | [MT WY] | [WY CO] | [CO NM] |         |         |         |         |
    | [MT ID] | [ID WY] | [CO NM] |         |         |         |         |
    | [MT ID] | [ID WY] | [WY CO] | [CO UT] | [UT NV] | [NV AZ] | [AZ NM] |


    Shortest path is [MT WY CO NM] Longest path is [MT ID WY CO UT NV AZ NM]
** DONE VWF
   CLOSED: [2017-11-24 Fri 23:05]
*** DONE HTC
    CLOSED: [2017-11-24 Fri 23:04]
    :LOGBOOK:
    CLOCK: [2017-11-24 Fri 23:01]--[2017-11-24 Fri 23:02] =>  0:01
    :END:
    D. D has three arrows pointed at it, and is pointing three directions. Abu said that he 
    won as many games as he lost, which would indicate that this is the correct node. 
*** DONE ABR
    CLOSED: [2017-11-24 Fri 23:04]
    :LOGBOOK:
    CLOCK: [2017-11-24 Fri 23:02]--[2017-11-24 Fri 23:04] =>  0:02
    :END:
    This graph is reflexive, every node loops to itself
    It is Antisymmetric, there are no bidirectional arrows
    It is Transitive. 
* Week 11 VWX
#+BEGIN: clocktable :maxlevel 2 :scope subtree
#+CAPTION: Clock summary at [2017-12-04 Mon 18:08]
| Headline          | Time   |      |
|-------------------+--------+------|
| *Total time*      | *8:37* |      |
|-------------------+--------+------|
| Week 11 VWX       | 8:37   |      |
| \_  Reading       |        | 0:46 |
| \_  Week 11 Day 1 |        | 1:02 |
| \_  Week 11 Day 2 |        | 1:01 |
| \_  VWD           |        | 0:13 |
| \_  VWH           |        | 1:01 |
| \_  VWI           |        | 0:25 |
| \_  VWJ           |        | 0:16 |
| \_  VWM           |        | 0:05 |
| \_  VWO           |        | 0:08 |
| \_  VWP           |        | 0:11 |
| \_  VWQ           |        | 0:32 |
| \_  VWR           |        | 2:49 |
| \_  VWS           |        | 0:08 |
#+END:

** Reading
   :LOGBOOK:
   CLOCK: [2017-12-02 Sat 13:54]--[2017-12-02 Sat 13:57] =>  0:03
   CLOCK: [2017-12-01 Fri 15:07]--[2017-12-01 Fri 15:22] =>  0:15
   CLOCK: [2017-12-01 Fri 14:05]--[2017-12-01 Fri 14:19] =>  0:14
   CLOCK: [2017-11-27 Mon 21:41]--[2017-11-27 Mon 21:49] =>  0:08
   CLOCK: [2017-11-27 Mon 18:18]--[2017-11-27 Mon 18:24] =>  0:06
   :END:
   
** Week 11 Day 1
   :LOGBOOK:
   CLOCK: [2017-11-28 Tue 10:13]--[2017-11-28 Tue 11:15] =>  1:02
   :END:
   
*** ICE - TSP 

   #+BEGIN_SRC emacs-lisp
   (retrieve-package 'bftsp)
   #+END_SRC 

   #+RESULTS:
   : 1559

   #+BEGIN_SRC emacs-lisp :results silent
   (defun distance (c1 c2)
    (sqrt (+ (expt (- (car c1) (car c2)) 2) (expt (- (cdr c1) (cdr c2)) 2)))
   )
   #+END_SRC

   #+BEGIN_SRC emacs-lisp :results raw
   (require 'bftsp)
   (bfTSP (build-distance-matrix cities-coords))
   #+END_SRC

   #+RESULTS:
   (2083.567653450519 1 6 4 3 5 9 7 2 8)

** Week 11 Day 2
   :LOGBOOK:
   CLOCK: [2017-11-30 Thu 10:14]--[2017-11-30 Thu 11:15] =>  1:01

   :END:
   
   
   
*** A whole new world
    
** DONE VWD
   CLOSED: [2017-12-01 Fri 18:56]
*** DONE KDB
    CLOSED: [2017-12-01 Fri 18:56]
    :LOGBOOK:
    CLOCK: [2017-12-01 Fri 18:43]--[2017-12-01 Fri 18:56] =>  0:13
    :END:


I started working on this last week. So I carried my work over

    #+BEGIN_SRC emacs-lisp
        (setq kdb-arcs '([ID MT] [ID WY] [ID NV] [ID UT] [MT WY] [WY UT] [WY CO]
                     [UT CO] [UT NV] [UT AZ] [CO NM] [AZ NM] [NV AZ])
          MT-NM-paths '(([MT WY] [WY CO] [CO NM])
                        ([MT ID] [ID WY] [WY CO] [CO NM])
                        ([MT ID] [ID UT] [UT WY] [WY CO] [CO NM])
                        ([MT ID] [ID WY] [WY CO] [CO UT] [UT NV] [NV AZ] [AZ NM])
                        ([MT ID] [ID NV] [NV AZ] [AZ NM])
                        ([MT ID] [ID UT] [UT NV] [NV AZ] [AZ NM])
                        ([MT ID] [ID UT] [UT AZ] [AZ NM])
                         ([MT ID] [ID UT] [UT CO] [CO NM])
                         ([MT ID] [ID WY] [WY UT] [UT NV] [NV AZ] [AZ NM])
                         ([MT ID] [ID WY] [WY UT] [UT NV] [NV CO] [CO NM])           
    )
    
    MT-NM-Simple-Paths '((MT ID NV AZ NM)
    (MT ID UT NV AZ NM)
    (MT ID UT AZ NM)
    (MT ID UT CO NM)
    (MT ID WY UT NV AZ NM)
    (MT ID WY UT AZ NM)
    (MT ID WY UT CO NM)
    (MT ID WY CO UT NV AZ NM)
    (MT ID WY CO UT AZ NM)
    (MT ID WY CO NM)
    (MT WY ID NV AZ NM)
    (MT WY ID NV UT CO NM)
    (MT WY ID NV UT AZ NM)
    (MT WY UT NV AZ NM)
    (MT WY UT AZ NM)
    (MT WY UT CO NM)
    (MT WY CO UT NV AZ NM)
    (MT WY CO NM)
    (MT ID UT WY CO NM)
    (MT ID NV AZ UT WY CO NM)
    (MT ID NV AZ UT CO NM)))
    #+END_SRC

    #+RESULTS:
    | MT | ID | NV | AZ | NM |    |    |    |
    | MT | ID | UT | NV | AZ | NM |    |    |
    | MT | ID | UT | AZ | NM |    |    |    |
    | MT | ID | UT | CO | NM |    |    |    |
    | MT | ID | WY | UT | NV | AZ | NM |    |
    | MT | ID | WY | UT | AZ | NM |    |    |
    | MT | ID | WY | UT | CO | NM |    |    |
    | MT | ID | WY | CO | UT | NV | AZ | NM | LARGEST
    | MT | ID | WY | CO | UT | AZ | NM |    |
    | MT | ID | WY | CO | NM |    |    |    |
    | MT | WY | ID | NV | AZ | NM |    |    |
    | MT | WY | ID | NV | UT | CO | NM |    |
    | MT | WY | ID | NV | UT | AZ | NM |    |
    | MT | WY | UT | NV | AZ | NM |    |    |
    | MT | WY | UT | AZ | NM |    |    |    |
    | MT | WY | UT | CO | NM |    |    |    |
    | MT | WY | CO | UT | NV | AZ | NM |    |
    | MT | WY | CO | NM |    |    |    |    | SMALLEST
    | MT | ID | UT | WY | CO | NM |    |    |
    | MT | ID | NV | AZ | UT | WY | CO | NM | LARGEST
    | MT | ID | NV | AZ | UT | CO | NM |    |

** VWH
*** KWD
    :LOGBOOK:
    CLOCK: [2017-11-27 Mon 18:25]--[2017-11-27 Mon 18:27] =>  0:02
    :END:
    [2 2 2 1 1 1 1]
*** HRR
    :LOGBOOK:
    CLOCK: [2017-11-27 Mon 18:25]--[2017-11-27 Mon 18:36] =>  0:11
    :END:
    This is a graph representation of the seven bridges of Koningsberg that were at the center
    of the problem which later gave birth to graph theory. You can see how this graph maps to the
    bridges by looking at this article -> http://mathworld.wolfram.com/KoenigsbergBridgeProblem.html

    The nodes represent land masses, and the links represent bridges from one landmass to the other. 

    A Eulerian graph meets the criteria for a Eulerian cycle. This means that you can begin at one vertex, 
    traverse the entire graph using each link exactly once, and end up back at the beginning vertex. Euler showed
    that if no graph vertices have an odd degree, it can be traveresed with an Eulerian cycle. 

    It is not a Eulerian graph. Loenhard Euler proved that it had no solution.
*** KEO
    :LOGBOOK:
    CLOCK: [2017-11-27 Mon 18:36]--[2017-11-27 Mon 18:45] =>  0:09
    :END:

    Although you can always construct a graph from a given degree sequence, it is possible however, that
    two or more distinct graphs have the same degree sequence. For this reason, I conclude that just having the
    degree sequence is not enough to reconstruct specific graphs. If you are looking to build a graph in general, than
    yes, it is enough.
*** HMO
    :LOGBOOK:
    CLOCK: [2017-12-04 Mon 17:52]--[2017-12-04 Mon 18:08] =>  0:16
    CLOCK: [2017-11-27 Mon 18:49]--[2017-11-27 Mon 19:12] =>  0:23
    :END:
  | 1 |   |   |   | 2 | 2 |   |   | 2 | 2 |   |   | 1 | 1 |
  |   |   |   |   |   |   |   |   |   |   |   |   | 4 |   |
  | 3 | 1 |   |   | 2 | 2 |   |   | 2 | 2 |   |   | 1 | 1 |
  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
  | 2 | 2 |   |   | 1 | 3 | 1 |   |   |   |   |   |   |   |
  | 3 | 3 |   |   |   |   |   |   |   |   |   |   |   |   |
  | 1 | 1 |   |   |   | 1 |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
  | 1 |   | 1 |   |   | 2 | 2 |   |   | 1 | 1 |   |   | 1 |
  |   | 3 |   |   |   |   |   |   |   |   |   |   |   | 1 |
  |   | 1 |   |   |   | 2 | 2 |   |   | 2 | 2 |   |   | 0 |

  *                 *--*           *--*          *  *
  |                 |  |           |  |          | /
  |                 |  |           |  |          *
  *--*              *--*           *--*          | \ 
                                                 *  *

  *--*     *--*--*     *   *      *--*    *   *   *
  |  |        |         \ /       |  |    |   |   |
  *--*        |          *        |  |    |   |   * 
  |  |        *          |        *--*    *---*   * 
                         *
  
  For your viewing pleasure. :)
** VWI
*** HIJ
    :LOGBOOK:
    CLOCK: [2017-11-27 Mon 19:13]--[2017-11-27 Mon 19:15] =>  0:02
    :END:
    Every degree represents a link from that node to another. That means that each link is 
    counted twice in the degree sequence. Logically then, if each link is counted twice in the 
    degree sequence, then the number of links is half the sum of the degree sequence. 
*** KLE
    :LOGBOOK:
    CLOCK: [2017-11-27 Mon 19:16]--[2017-11-27 Mon 19:28] =>  0:12
    :END:
    
    Let G = (v,e) be the graph of vertices and edges
    Suppose V = {v_1 v_2 ... v_n } is the set of vertices in G
    The handshake theorem says:

    2|E(G)| = deg(v_1) + deg(v_2) + ... deg(v_n)
       \uparrow                   \uparrow
   This side          Which implies that this     
   of the             side of the equation must 
   equation           also always be even
   is always 
   even

   A sum with an odd number of odds cannot be even, so that implies that
   there cannot be an odd number of vertices with odd degrees.
*** HAB
    :LOGBOOK:
    CLOCK: [2017-11-27 Mon 21:49]--[2017-11-27 Mon 21:55] =>  0:06
    CLOCK: [2017-11-27 Mon 19:28]--[2017-11-27 Mon 19:33] =>  0:05
    :END:
    No. It is not possible, because there is no way to connect the 3 node three ways 
    (only two linking options: node 1 node 2) without either linking to the same node
    twice, or linking to itself. Both of these
    violate the rules of a simple graph, hence, it is not possible. 
** DONE VWJ
   CLOSED: [2017-12-01 Fri 19:01]
*** DONE KOV
    CLOSED: [2017-12-01 Fri 19:01]
    :LOGBOOK:
    CLOCK: [2017-12-01 Fri 18:58]--[2017-12-01 Fri 19:01] =>  0:03
    CLOCK: [2017-11-27 Mon 21:55]--[2017-11-27 Mon 22:04] =>  0:09
    :END:
    
    D is adjacent to E F G
    D is adjacent from A B C
    k comes from D
    k,i,j go to E F G
    k,i,j connect D to E F G
    k,i,j go from D to E F G
    D is the initial node of k,i,and j
    E F G are terminal nodes of k, i, and j

*** HBT
    :LOGBOOK:
    CLOCK: [2017-11-27 Mon 22:04]--[2017-11-27 Mon 22:08] =>  0:04
    :END:
    
    #+BEGIN_SRC emacs-lisp
    (list [A F] [A B F] [A B C F] [A B C D F] [A B C D E F]
          [A B E F] [A B D F] [A C F] [A C E F] [A C D F] [A C D E F]
          [A D F] [A D E F] [A E F])
    #+END_SRC

    #+RESULTS:
    | [A F] | [A B F] | [A B C F] | [A B C D F] | [A B C D E F] | [A B E F] | [A B D F] | [A C F] | [A C E F] | [A C D F] | [A C D E F] | [A D F] | [A D E F] | [A E F] |

    Zero of the paths cross the node G
** VWM
*** AGA
    :LOGBOOK:
    CLOCK: [2017-12-01 Fri 13:45]--[2017-12-01 Fri 13:50] =>  0:05
    :END:
    0 Nodes and 0 links
** VWO
   
*** KNF
    :LOGBOOK:
    CLOCK: [2017-12-01 Fri 13:55]--[2017-12-01 Fri 14:03] =>  0:08
    :END:
    W_5 = [5 3 3 3 3 3]

    W_n = [n 3_1 3_2 ... 3_n]
** VWP
*** HJS
    :LOGBOOK:
    CLOCK: [2017-12-01 Fri 14:19]--[2017-12-01 Fri 14:30] =>  0:11
    :END:
    Q_1 = 2 nodes 1 link
    Q_2 = 4 nodes 4 links
    Q_3 = 8 nodes 12 links
    Q_4 = 16 nodes 

    so n*2^(n-1)
** VWQ
*** HAX
    :LOGBOOK:
    CLOCK: [2017-12-01 Fri 14:30]--[2017-12-01 Fri 14:40] =>  0:10
    :END:
    m is the set of nodes on the upper/top portion of the graph
    n is the set of nodes on the lower/bottom portion of the graph
*** KHQ
    :LOGBOOK:
    CLOCK: [2017-12-01 Fri 14:40]--[2017-12-01 Fri 14:47] =>  0:07
    :END:

    They are both complete graphs, 
    
*** HKE
    :LOGBOOK:
    CLOCK: [2017-12-01 Fri 14:49]--[2017-12-01 Fri 14:54] =>  0:05
    :END:
    Bipartite graphs are good for data representation. Data to be searched for can be kept
    in set m, and set n can contain the data. You can then use matching algorithms to match data between sets
*** KBB
    :LOGBOOK:
    CLOCK: [2017-12-01 Fri 14:54]--[2017-12-01 Fri 15:04] =>  0:10
    :END:

    A tripartite would follow the same idea as a bipartite, three sets of nodes composed so that no two nodes within 
    the same set are adjacent. For an example of what a complete tripartite graph would look like, check this page out: 
    http://mathworld.wolfram.com/CompleteTripartiteGraph.html

    An npartite would follow the above principles. N sets of nodes composed so that no two nodes within the same set are adjacent. 
    Examples of these graphs can be found here: 
    http://mathworld.wolfram.com/Completek-PartiteGraph.html
** VWR
*** HRL 
    :LOGBOOK:
    CLOCK: [2017-12-01 Fri 15:04]--[2017-12-01 Fri 15:22] =>  0:18
    :END:

         d
       / |\
      t--e \
    / |  |  \
   p--q  m--c
    \ | / /
      n--/
*** AGD
    :LOGBOOK:
    CLOCK: [2017-12-02 Sat 12:07]--[2017-12-02 Sat 12:53] =>  0:46
    CLOCK: [2017-12-01 Fri 18:02]--[2017-12-01 Fri 18:40] =>  0:38
    CLOCK: [2017-12-01 Fri 15:25]--[2017-12-01 Fri 15:38] =>  0:13
    :END:
    #+BEGIN_SRC emacs-lisp :results silent
(defun make-adjacency-list (node links)
  "Make the adjacency list of a node by collecting
all the nodes it's connected to in links."
  (loop for link in links
        if (= node (car link))
        collect (cdr link)))

(defun make-adjacency-list-in-reverse (node links)
  "Make the reverse adjacency list of a node by collecting
all the nodes connected to it in links."
  (loop for link in links
        if (= node (cdr link))
        collect (car link)))

(defun make-adjacency-lists (nodes links)
  "Make adjacency lists given a graph's nodes and links
by collecting the adjacency lists and reverse adjacency lists
for each of the graph's nodes, removing any duplicates found."
  (let ((alists nil) the-nodes-alist)
    (loop for node in nodes
          do (setq the-nodes-alist
                   (remove-duplicates
                    (nconc (make-adjacency-list node links)
                           (make-adjacency-list-in-reverse node links)))
                   alists (nconc alists (list (cons node the-nodes-alist)))))
    alists))




(defun make-adj-list-table (nodes links)
"Generate an adjacency list table"
(let ((alists nil) the-nodes-alist)
      (mapcar (lambda (node) 
         (progn
         (setq 
            AL (format "%s" (make-adjacency-list node links))
            AL-R (format "%s" (make-adjacency-list-in-reverse node links))
            merge (sort (remove-duplicates 
                         (nconc (make-adjacency-list node links) (make-adjacency-list-in-reverse node links)) 
                        )#'<)
            row (list node AL AL-R merge)
            alists (nconc alists (list row))
         ))
      ) nodes)
alists))


    #+END_SRC


#+BEGIN_SRC emacs-lisp
(setq graph-11-27-links '(
   (1 . 2) (1 . 9) (1 . 10) (1 . 11) (2 . 3) (2 . 4) (2 . 5)
   (2 . 9) (2 . 10) (2 . 11) (3 . 4) (3 . 10) (3 . 11)
   (4 . 5) (4 . 10) (4 . 11) (5 . 6) (5 . 7) (5 . 9) (6 . 7)
   (6 . 9) (7 . 8) (7 . 9) (8 . 10) (8 . 9) (9 . 10) (10 . 11))
      graph-11-27-nodes '(1 2 3 4 5 6 7 8 9 10 11))

(make-adj-list-table graph-11-27-nodes graph-11-27-links)
#+END_SRC

#+RESULTS:
|  1 | (2 9 10 11)     | nil           | (2 9 10 11)       |
|  2 | (3 4 5 9 10 11) | (1)           | (1 3 4 5 9 10 11) |
|  3 | (4 10 11)       | (2)           | (2 4 10 11)       |
|  4 | (5 10 11)       | (2 3)         | (2 3 5 10 11)     |
|  5 | (6 7 9)         | (2 4)         | (2 4 6 7 9)       |
|  6 | (7 9)           | (5)           | (5 7 9)           |
|  7 | (8 9)           | (5 6)         | (5 6 8 9)         |
|  8 | (10 9)          | (7)           | (7 9 10)          |
|  9 | (10)            | (1 2 5 6 7 8) | (1 2 5 6 7 8 10)  |
| 10 | (11)            | (1 2 3 4 8 9) | (1 2 3 4 8 9 11)  |
| 11 | nil             | (1 2 3 4 10)  | (1 2 3 4 10)      |

*** HSG
    :LOGBOOK:
    CLOCK: [2017-12-02 Sat 12:55]--[2017-12-02 Sat 13:42] =>  0:47
    CLOCK: [2017-12-01 Fri 19:01]--[2017-12-01 Fri 19:08] =>  0:07
    :END:
   #+BEGIN_SRC emacs-lisp :results raw 
(setq adjacency-matrix (make-vector 12 nil))
(dotimes (i 12) (setf (aref adjacency-matrix i) (make-vector 12 0)))

(mapcar (lambda (j) (aset (aref adjacency-matrix 0) j j))
(number-sequence 1 11))

(mapcar (lambda (k) 
(progn 
   (aset (aref adjacency-matrix k) 0 k)
   (mapcar (lambda (l) (aset (aref adjacency-matrix k) l 1)) 
   (remove-duplicates
      (nconc (make-adjacency-list k graph-11-27-links)
             (make-adjacency-list-in-reverse k graph-11-27-links))))
)
) (number-sequence 1 11))
   
   #+END_SRC 

   #+RESULTS:
   ((1 1 1 1) (1 1 1 1 1 1 1) (1 1 1 1) (1 1 1 1 1) (1 1 1 1 1) (1 1 1) (1 1 1 1) (1 1 1) (1 1 1 1 1 1 1) (1 1 1 1 1 1 1) (1 1 1 1 1))


   #+BEGIN_SRC emacs-lisp
   (setq adjacency-matrix (make-vector 12 nil))
(dotimes (i 12) (setf (aref adjacency-matrix i) (make-vector 12 0)))

   (loop for i from 1 to 11
      do (aset (aref adjacency-matrix 0) i i))

   (loop for i from 1 to 11
      do (progn 
          (aset (aref adjacency-matrix i) 0 i)
          (loop for j in (remove-duplicates
                         (nconc (make-adjacency-list i graph-11-27-links)
                                (make-adjacency-list-in-reverse i graph-11-27-links)))
                          do (aset (aref adjacency-matrix i) j 1))))
      adjacency-matrix
   #+END_SRC

   #+RESULTS:
   : [[0 1 2 3 4 5 6 7 8 9 10 11] [1 0 1 0 0 0 0 0 0 1 1 1] [2 1 0 1 1 1 0 0 0 1 1 1] [3 0 1 0 1 0 0 0 0 0 1 1] [4 0 1 1 0 1 0 0 0 0 1 1] [5 0 1 0 1 0 1 1 0 1 0 0] [6 0 0 0 0 1 0 1 0 1 0 0] [7 0 0 0 0 1 1 0 1 1 0 0] [8 0 0 0 0 0 0 1 0 1 1 0] [9 1 1 0 0 1 1 1 1 0 1 0] [10 1 1 1 1 0 0 0 1 1 0 1] [11 1 1 1 1 0 0 0 0 0 1 0]]
   
** VWS
   
*** KHO
    :LOGBOOK:
    CLOCK: [2017-12-02 Sat 14:10]--[2017-12-02 Sat 14:18] =>  0:08
    :END:
    
    [EI]
    [GH]
    [ABCDEGH]
    [DE] [DH]
    [AB] [AC] [AG]
    [BD] [BE]
    [CD] [CH]

*** ANA

    #+BEGIN_SRC emacs-lisp
    (defun link-exists (graph-representation node1 node2)
  "Given a graph representation, is there a link between node1 and node2?"
  (not
   (null
    (or
     (member node2 (get-adjacency-list graph-representation node1))
     (member node1 (get-adjacency-list graph-representation node2))))))

(defun check-clique-or-anti-clique (graph-representation nodes anti)
  "Checks if the represented graph contains a subgraph consisting of
the given nodes that is a clique (if anti is nil) or an anti-clique
(if anti is t). Returns t or nil appropriately."
   ;; ... your code goes here
  )
    #+END_SRC

